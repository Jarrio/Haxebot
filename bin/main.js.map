{
"version":3,
"file":"main.js",
"sourceRoot":"file:///",
"sources":["C:/Development/HaxeToolkit/haxe/std/js/_std/HxOverrides.hx","C:/Development/HaxeToolkit/haxe/std/Lambda.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/src/Main.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/macros/UniverseMacros.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/safety/1,1,2/src/Safety.hx","C:/Development/HaxeToolkit/haxe/std/js/_std/Std.hx","C:/Development/HaxeToolkit/haxe/std/StringTools.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/src/Util.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/bits/1,3,0/src/bits/Bits.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/Components.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/Entity.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/Family.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/System.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/Universe.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/core/ComponentManager.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/macros/ComponentMacros.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/core/EntityManager.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/core/FamilyManager.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/macros/FamilyMacros.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/core/ResourceManager.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/macros/ResourceMacros.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/core/SystemManager.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/ds/Set.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/ds/Signal.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/ds/SparseSet.hx","C:/Development/HaxeToolkit/haxe/std/js/_std/haxe/ds/StringMap.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/macros/ComponentCache.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/macros/FamilyCache.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/macros/ResourceCache.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/aidan-ecs/git/src/ecs/macros/SystemMacros.hx","C:/Development/HaxeToolkit/haxe/std/js/_std/haxe/Exception.hx","C:/Development/HaxeToolkit/haxe/std/haxe/Log.hx","C:/Development/HaxeToolkit/haxe/std/haxe/Timer.hx","C:/Development/HaxeToolkit/haxe/std/haxe/ValueException.hx","C:/Development/HaxeToolkit/haxe/std/haxe/exceptions/PosException.hx","C:/Development/HaxeToolkit/haxe/std/haxe/exceptions/NotImplementedException.hx","C:/Development/HaxeToolkit/haxe/std/js/_std/haxe/io/Bytes.hx","C:/Development/HaxeToolkit/haxe/std/haxe/io/Eof.hx","C:/Development/HaxeToolkit/haxe/std/haxe/iterators/ArrayIterator.hx","C:/Development/HaxeToolkit/haxe/std/haxe/macro/TypeTools.hx","C:/Development/HaxeToolkit/haxe/std/js/Boot.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/hxnodejs/12,1,0/src/js/node/KeyValue.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/hxnodejs/12,1,0/src/js/node/stream/Writable.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/safety/1,1,2/src/safety/SafetyException.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/safety/1,1,2/src/safety/NullPointerException.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/hxnodejs/12,1,0/src/sys/FileSystem.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/hxnodejs/12,1,0/src/sys/io/FileInput.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/.haxelib/hxnodejs/12,1,0/src/sys/io/FileOutput.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/src/systems/CommandBase.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/src/systems/Messages.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/src/systems/commands/Haxelib.hx","c:/Users/Jazz9/Documents/Projects/haxe/node/Haxebot/src/systems/commands/Hi.hx"],
"sourcesContent":["/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n@:noDoc\r\nclass HxOverrides {\r\n\tstatic function dateStr(date:Date):String {\r\n\t\tvar m = date.getMonth() + 1;\r\n\t\tvar d = date.getDate();\r\n\t\tvar h = date.getHours();\r\n\t\tvar mi = date.getMinutes();\r\n\t\tvar s = date.getSeconds();\r\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\r\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\r\n\t}\r\n\r\n\tstatic function strDate(s:String):Date {\r\n\t\tswitch (s.length) {\r\n\t\t\tcase 8: // hh:mm:ss\r\n\t\t\t\tvar k = s.split(\":\");\r\n\t\t\t\tvar d = js.Syntax.construct(Date);\r\n\t\t\t\t(cast d)[cast \"setTime\"](0);\r\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\r\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\r\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\r\n\t\t\t\treturn d;\r\n\t\t\tcase 10: // YYYY-MM-DD\r\n\t\t\t\tvar k = s.split(\"-\");\r\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\r\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\r\n\t\t\t\tvar k = s.split(\" \");\r\n\t\t\t\tvar y = k[0].split(\"-\");\r\n\t\t\t\tvar t = k[1].split(\":\");\r\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow \"Invalid date format : \" + s;\r\n\t\t}\r\n\t}\r\n\r\n\t@:pure\r\n\tstatic function cca(s:String, index:Int):Null<Int> {\r\n\t\tvar x = (cast s).charCodeAt(index);\r\n\t\tif (x != x) // fast isNaN\r\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\r\n\t\treturn x;\r\n\t}\r\n\r\n\t@:pure\r\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\r\n\t\tif (len == null) {\r\n\t\t\tlen = s.length;\r\n\t\t} else if (len < 0) {\r\n\t\t\tif (pos == 0)\r\n\t\t\t\tlen = s.length + len;\r\n\t\t\telse\r\n\t\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\t#if (js_es < 5)\r\n\t\tif (pos < 0) {\r\n\t\t\tpos = s.length + pos;\r\n\t\t\tif (pos < 0)\r\n\t\t\t\tpos = 0;\r\n\t\t}\r\n\t\t#end\r\n\r\n\t\treturn (cast s).substr(pos, len);\r\n\t}\r\n\r\n\t@:pure\r\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\r\n\t\tvar len = a.length;\r\n\t\tif (i < 0) {\r\n\t\t\ti += len;\r\n\t\t\tif (i < 0)\r\n\t\t\t\ti = 0;\r\n\t\t}\r\n\t\twhile (i < len) {\r\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\r\n\t\t\t\treturn i;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t@:pure\r\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\r\n\t\tvar len = a.length;\r\n\t\tif (i >= len)\r\n\t\t\ti = len - 1;\r\n\t\telse if (i < 0)\r\n\t\t\ti += len;\r\n\t\twhile (i >= 0) {\r\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\r\n\t\t\t\treturn i;\r\n\t\t\ti--;\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tstatic function remove<T>(a:Array<T>, obj:T) {\r\n\t\tvar i = a.indexOf(obj);\r\n\t\tif (i == -1)\r\n\t\t\treturn false;\r\n\t\ta.splice(i, 1);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@:pure\r\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\r\n\t\tuntyped {\r\n\t\t\treturn {\r\n\t\t\t\tcur: 0,\r\n\t\t\t\tarr: a,\r\n\t\t\t\thasNext: function() {\r\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\r\n\t\t\t\t},\r\n\t\t\t\tnext: function() {\r\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\", \"closure_read.keyValueIterator\")\r\n\tstatic function keyValueIter<T>( a : Array<T> ) {\r\n\t\treturn new haxe.iterators.ArrayKeyValueIterator(a);\r\n\t}\r\n\r\n\t@:pure\r\n\tstatic function now(): Float return js.lib.Date.now();\r\n\r\n\tstatic function __init__()\r\n\t\tuntyped {\r\n\t\t\t#if (js_es < 5)\r\n\t\t\t__feature__('HxOverrides.indexOf',\r\n\t\t\t\tif (Array.prototype.indexOf) js.Syntax.code(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\r\n\t\t\t__feature__('HxOverrides.lastIndexOf',\r\n\t\t\t\tif (Array.prototype.lastIndexOf) js.Syntax.code(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\r\n\t\t\t#end\r\n\r\n\t\t\t__feature__('HxOverrides.now',\r\n\t\t\t\tif (js.Syntax.typeof(performance) != 'undefined' && js.Syntax.typeof(performance.now) == 'function') {\r\n\t\t\t\t\tHxOverrides.now = performance.now.bind(performance);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n}\r\n","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nimport haxe.ds.List;\r\n\r\n/**\r\n\tThe `Lambda` class is a collection of methods to support functional\r\n\tprogramming. It is ideally used with `using Lambda` and then acts as an\r\n\textension to Iterable types.\r\n\r\n\tOn static platforms, working with the Iterable structure might be slower\r\n\tthan performing the operations directly on known types, such as Array and\r\n\tList.\r\n\r\n\tIf the first argument to any of the methods is null, the result is\r\n\tunspecified.\r\n\r\n\t@see https://haxe.org/manual/std-Lambda.html\r\n**/\r\nclass Lambda {\r\n\t/**\r\n\t\tCreates an Array from Iterable `it`.\r\n\r\n\t\tIf `it` is an Array, this function returns a copy of it.\r\n\t**/\r\n\tpublic static function array<A>(it:Iterable<A>):Array<A> {\r\n\t\tvar a = new Array<A>();\r\n\t\tfor (i in it)\r\n\t\t\ta.push(i);\r\n\t\treturn a;\r\n\t}\r\n\r\n\t/**\r\n\t\tCreates a List form Iterable `it`.\r\n\r\n\t\tIf `it` is a List, this function returns a copy of it.\r\n\t**/\r\n\tpublic static function list<A>(it:Iterable<A>):List<A> {\r\n\t\tvar l = new List<A>();\r\n\t\tfor (i in it)\r\n\t\t\tl.add(i);\r\n\t\treturn l;\r\n\t}\r\n\r\n\t/**\r\n\t\tCreates a new Array by applying function `f` to all elements of `it`.\r\n\t\tThe order of elements is preserved.\r\n\t\tIf `f` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static inline function map<A, B>(it:Iterable<A>, f:(item:A) -> B):Array<B> {\r\n\t\treturn [for (x in it) f(x)];\r\n\t}\r\n\r\n\t/**\r\n\t\tSimilar to map, but also passes the index of each element to `f`.\r\n\t\tThe order of elements is preserved.\r\n\t\tIf `f` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static inline function mapi<A, B>(it:Iterable<A>, f:(index:Int, item:A) -> B):Array<B> {\r\n\t\tvar i = 0;\r\n\t\treturn [for (x in it) f(i++, x)];\r\n\t}\r\n\r\n\t/**\r\n\t\tConcatenate a list of iterables.\r\n\t\tThe order of elements is preserved.\r\n\t**/\r\n\tpublic static inline function flatten<A>(it:Iterable<Iterable<A>>):Array<A> {\r\n\t\treturn [for (e in it) for (x in e) x];\r\n\t}\r\n\r\n\t/**\r\n\t\tA composition of map and flatten.\r\n\t\tThe order of elements is preserved.\r\n\t\tIf `f` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static inline function flatMap<A, B>(it:Iterable<A>, f:(item:A) -> Iterable<B>):Array<B> {\r\n\t\treturn Lambda.flatten(Lambda.map(it, f));\r\n\t}\r\n\r\n\t/**\r\n\t\tTells if `it` contains `elt`.\r\n\r\n\t\tThis function returns true as soon as an element is found which is equal\r\n\t\tto `elt` according to the `==` operator.\r\n\r\n\t\tIf no such element is found, the result is false.\r\n\t**/\r\n\tpublic static function has<A>(it:Iterable<A>, elt:A):Bool {\r\n\t\tfor (x in it)\r\n\t\t\tif (x == elt)\r\n\t\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t\tTells if `it` contains an element for which `f` is true.\r\n\r\n\t\tThis function returns true as soon as an element is found for which a\r\n\t\tcall to `f` returns true.\r\n\r\n\t\tIf no such element is found, the result is false.\r\n\r\n\t\tIf `f` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static function exists<A>(it:Iterable<A>, f:(item:A) -> Bool) {\r\n\t\tfor (x in it)\r\n\t\t\tif (f(x))\r\n\t\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t\tTells if `f` is true for all elements of `it`.\r\n\r\n\t\tThis function returns false as soon as an element is found for which a\r\n\t\tcall to `f` returns false.\r\n\r\n\t\tIf no such element is found, the result is true.\r\n\r\n\t\tIn particular, this function always returns true if `it` is empty.\r\n\r\n\t\tIf `f` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static function foreach<A>(it:Iterable<A>, f:(item:A) -> Bool) {\r\n\t\tfor (x in it)\r\n\t\t\tif (!f(x))\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t\tCalls `f` on all elements of `it`, in order.\r\n\r\n\t\tIf `f` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static function iter<A>(it:Iterable<A>, f:(item:A) -> Void) {\r\n\t\tfor (x in it)\r\n\t\t\tf(x);\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns a Array containing those elements of `it` for which `f` returned\r\n\t\ttrue.\r\n\t\tIf `it` is empty, the result is the empty Array even if `f` is null.\r\n\t\tOtherwise if `f` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static function filter<A>(it:Iterable<A>, f:(item:A) -> Bool) {\r\n\t\treturn [for (x in it) if (f(x)) x];\r\n\t}\r\n\r\n\t/**\r\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\r\n\t\t`first`.\r\n\r\n\t\tIf `it` has no elements, the result is `first`.\r\n\r\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\r\n\t\tThe result of that call is then passed to `f` with the next element of\r\n\t\t`it`, and so on until `it` has no more elements.\r\n\r\n\t\tIf `it` or `f` are null, the result is unspecified.\r\n\t**/\r\n\tpublic static function fold<A, B>(it:Iterable<A>, f:(item:A, result:B) -> B, first:B):B {\r\n\t\tfor (x in it)\r\n\t\t\tfirst = f(x, first);\r\n\t\treturn first;\r\n\t}\r\n\r\n\t/**\r\n\t\tSimilar to fold, but also passes the index of each element to `f`.\r\n\r\n\t\tIf `it` or `f` are null, the result is unspecified.\r\n\t**/\r\n\tpublic static function foldi<A, B>(it:Iterable<A>, f:(item:A, result:B, index:Int) -> B, first:B):B {\r\n\t\tvar i = 0;\r\n\t\tfor (x in it) {\r\n\t\t\tfirst = f(x, first, i);\r\n\t\t\t++i;\r\n\t\t}\r\n\t\treturn first;\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\r\n\t\ttotal number of elements in `it` if `pred` is null.\r\n\r\n\t\tThis function traverses all elements.\r\n\t**/\r\n\tpublic static function count<A>(it:Iterable<A>, ?pred:(item:A) -> Bool) {\r\n\t\tvar n = 0;\r\n\t\tif (pred == null)\r\n\t\t\tfor (_ in it)\r\n\t\t\t\tn++;\r\n\t\telse\r\n\t\t\tfor (x in it)\r\n\t\t\t\tif (pred(x))\r\n\t\t\t\t\tn++;\r\n\t\treturn n;\r\n\t}\r\n\r\n\t/**\r\n\t\tTells if Iterable `it` does not contain any element.\r\n\t**/\r\n\tpublic static function empty<T>(it:Iterable<T>):Bool {\r\n\t\treturn !it.iterator().hasNext();\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns the index of the first element `v` within Iterable `it`.\r\n\r\n\t\tThis function uses operator `==` to check for equality.\r\n\r\n\t\tIf `v` does not exist in `it`, the result is -1.\r\n\t**/\r\n\tpublic static function indexOf<T>(it:Iterable<T>, v:T):Int {\r\n\t\tvar i = 0;\r\n\t\tfor (v2 in it) {\r\n\t\t\tif (v == v2)\r\n\t\t\t\treturn i;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns the first element of `it` for which `f` is true.\r\n\r\n\t\tThis function returns as soon as an element is found for which a call to\r\n\t\t`f` returns true.\r\n\r\n\t\tIf no such element is found, the result is null.\r\n\r\n\t\tIf `f` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static function find<T>(it:Iterable<T>, f:(item:T) -> Bool):Null<T> {\r\n\t\tfor (v in it) {\r\n\t\t\tif (f(v))\r\n\t\t\t\treturn v;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns the index of the first element of `it` for which `f` is true.\r\n\r\n\t\tThis function returns as soon as an element is found for which a call to\r\n\t\t`f` returns true.\r\n\r\n\t\tIf no such element is found, the result is -1.\r\n\r\n\t\tIf `f` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static function findIndex<T>(it:Iterable<T>, f:(item:T) -> Bool):Int {\r\n\t\tvar i = 0;\r\n\t\tfor (v in it) {\r\n\t\t\tif (f(v))\r\n\t\t\t\treturn i;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns a new Array containing all elements of Iterable `a` followed by\r\n\t\tall elements of Iterable `b`.\r\n\r\n\t\tIf `a` or `b` are null, the result is unspecified.\r\n\t**/\r\n\tpublic static function concat<T>(a:Iterable<T>, b:Iterable<T>):Array<T> {\r\n\t\tvar l = new Array();\r\n\t\tfor (x in a)\r\n\t\t\tl.push(x);\r\n\t\tfor (x in b)\r\n\t\t\tl.push(x);\r\n\t\treturn l;\r\n\t}\r\n}\r\n","import discord_js.Message;\nimport discord_js.Client;\nimport haxe.Json;\nimport sys.io.File;\nimport ecs.Universe;\nimport haxe.Timer;\nimport systems.Messages;\nimport components.Command;\nimport systems.commands.Hi;\nimport systems.commands.Haxelib;\nimport systems.CommandBase;\n\nclass Main {\n\tpublic static var connected:Bool = false;\n\tpublic static var config:TConfig;\n\tpublic static var universe:Universe;\n\tpublic static function start() {\n\t\tuniverse = new Universe(1000);\n\n\t\tuniverse.setSystems(\n\t\t\tHaxelib\n\t\t);\n\n\t\tvar client = new Client();\n\t\tclient.on('ready', function(_) {\n\t\t\tconnected = true;\n\t\t\ttrace(\"HaxeBot Ready!\");\n\t\t});\n\n\t\tclient.on('message', function(message:Message) {\n\t\t\t\n\t\t\tvar split = message.content.split(' ');\n\t\t\tvar first_word = split[0];\n\t\t\tvar content = null;\n\t\t\tif (split.length > 1) {\n\t\t\t\tcontent = message.content.substring(first_word.length);\n\t\t\t}\n\t\t\t\n\t\t\tfor (prefix in config.prefixes) {\n\t\t\t\tif (prefix == first_word.charAt(0)) {\n\t\t\t\t\tvar command = ({\n\t\t\t\t\t\tname: first_word.trim(), \n\t\t\t\t\t\tcontent: content.trim()\n\t\t\t\t\t}:Command);\n\t\t\t\t\tuniverse.setComponents(universe.createEntity(), command, message);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tclient.login(config.discord_api_key).then(function(reply) {\n\t\t\ttrace(\"HaxeBot logged in!\");\n\t\t}, function(error) {\n\t\t\ttrace(\"HaxeBot Error!\");\n\t\t\ttrace(error);\n\t\t});\n\n\t\tnew Timer(100).run = function() {\n\t\t\tuniverse.update(1);\n\t\t}\n\t}\n\n\tstatic function main() {\n\t\ttry {\n\t\t\tconfig = Json.parse(File.getContent('./bin/config.json'));\n\t\t} catch (e) {\n\t\t\ttrace(e.message);\n\t\t}\n\n\t\tif (config == null || config.discord_api_key == 'TOKEN_HERE') {\n\t\t\tthrow ('Enter your discord auth token.');\n\t\t}\n\n\t\tstart();\n\t}\n}\n\ntypedef TConfig = {\n\tvar macros:Bool;\n\tvar prefixes:Array<String>;\n\tvar discord_api_key:String;\n}","package ecs.macros;\r\n\r\nimport ecs.macros.ComponentCache.registerComponent;\r\nimport ecs.macros.ResourceCache.registerResource;\r\nimport ecs.ds.Set;\r\nimport ecs.ds.Result;\r\nimport haxe.ds.Option;\r\nimport haxe.macro.Context;\r\nimport haxe.macro.Type.ClassType;\r\nimport haxe.macro.Type.TVar;\r\nimport haxe.macro.Expr;\r\nimport ecs.macros.ResourceCache.getResourceID;\r\nimport ecs.macros.ComponentCache.getComponentID;\r\nimport ecs.macros.FamilyCache.getFamilyByKey;\r\nimport ecs.macros.FamilyCache.getFamilyIDsWithResource;\r\nimport ecs.macros.FamilyCache.getFamilyIDsWithComponent;\r\n\r\nusing Safety;\r\nusing haxe.macro.Tools;\r\n\r\n/**\r\n * This module contains all the user facing macro functions needed to easily work with a universe.\r\n * Functions within this module are designed to be used as static extensions to a universe object,\r\n * the exception to this is `iterate` which cannot be used if this module is included with `using`.\r\n * A way around this should be found.\r\n */\r\n\r\n/**\r\n * Creates a new entity within the provided universe.\r\n * If the maximum number of entities has been reached an exception is thrown.\r\n * \r\n * Example usage for `using ecs.macros.UniverseMacros;`\r\n * \r\n * ```\r\n * final ent = universe.createEntity();\r\n * final ent = this.createEntity();\r\n * \r\n * ```\r\n * The first line would be an example for when you have access the universe object (e.g. having just created it, or calling from inside a system).\r\n * Second line would be if you are extending the universe and calling from within the sub class. The `this.` part is required in this case.\r\n * \r\n * @param _universe Universe to create the entity within.\r\n * @return Created entity ID.\r\n * @throws UniverseFullException Thrown if there is not enough space in the universe for another entity.\r\n */\r\nmacro function createEntity(_universe : ExprOf<Universe>) : ExprOf<Entity>\r\n{\r\n    return macro $e{ _universe }.entities.create();\r\n}\r\n\r\n/**\r\n * Destroy an entity and all its attached components from the given universe.\r\n * If the provided universe does not contain the entity then no operation is performed.\r\n * \r\n * Example usage for `using ecs.macros.UniverseMacros;`\r\n * \r\n * ```\r\n * final ent = // an entity is assigned to this field from somewhere\r\n * universe.destroyEntity(ent);\r\n * this.destroyEntity(ent);\r\n * ```\r\n * \r\n * \r\n * @param _universe Universe to remove the entity from.\r\n * @param _entity Entity ID.\r\n */\r\nmacro function destroyEntity(_universe : ExprOf<Universe>, _entity : ExprOf<Entity>)\r\n{\r\n    return macro {\r\n        final _ecsTmpEntity = $e{ _entity };\r\n        $e{ _universe }.components.clear(_ecsTmpEntity);\r\n        $e{ _universe }.families.whenEntityDestroyed(_ecsTmpEntity);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets any number of components on an entity in a specific universe.\r\n * The final argument is a rest argument meaning it can take in any number of arguments.\r\n * \r\n * Example usage for `using ecs.macros.UniverseMacros;`\r\n * \r\n * ```\r\n * unverse.setComponents(myEntity,\r\n *     new Position(32, 32),\r\n *     new Velocity(),\r\n *     new Sprite('assets/player.png'));\r\n * ```\r\n * \r\n * Along with the usual variable, function, and constructor expressions if the component has a constructor\r\n * with no arguments then simply passing in the type will construct a new component for it.\r\n * \r\n * ```\r\n * universe.setComponents(myEntity,\r\n *     new Position(32, 32),\r\n *     Velocity,\r\n *     new Sprite('assets/player.png));\r\n * ```\r\n * \r\n * It is also possible to use basic types for components.\r\n * \r\n * ```\r\n * universe.setComponents(myEntity, 7, 4.2, true, 'hello world');\r\n * ```\r\n * \r\n * Attempting to add a component which is not used in any families will result in a compiler warning and that\r\n * expression will not be typed (no functions or property getters would be called if used).\r\n * Setting a component onto an entity which already has a component of that type will replace it.\r\n * \r\n * @param _universe Universe which contains the entity.\r\n * @param _entity Entity to add components to.\r\n * @param _components Components to add.\r\n */\r\nmacro function setComponents(_universe : ExprOf<Universe>, _entity : Expr, _components : Array<Expr>)\r\n{\r\n    final staticLoading = Context.defined('ecs.static_loading');\r\n    final exprs         = [ macro final _ecsTmpEntity = $e{ _entity } ];\r\n    final added         = new Set();\r\n    final insert        = (id, compExpr) -> {\r\n        exprs.push(macro $e{ _universe }.components.set(_ecsTmpEntity, $v{ id }, $e{ compExpr }));\r\n\r\n        if (staticLoading)\r\n        {\r\n            for (familyID in getFamilyIDsWithComponent(id))\r\n            {\r\n                added.add(familyID);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (component in _components)\r\n    {\r\n        switch component.expr\r\n        {\r\n            case EConst(CIdent(s)):\r\n                switch isLocalIdent(s, Context.getLocalType().getClass(), Context.getLocalTVars())\r\n                {\r\n                    case Some(type):\r\n                        if (staticLoading)\r\n                        {\r\n                            switch getComponentID(Utils.signature(type))\r\n                            {\r\n                                case Some(id): insert(id, component);\r\n                                case None: Context.warning('Local ident $s : $type is not used in any families', component.pos);\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            insert(registerComponent(Utils.signature(type), type), component);\r\n                        }\r\n                    case None:\r\n                        final resolved  = Context.getType(s);\r\n                        final signature = Utils.signature(resolved);\r\n\r\n                        if (staticLoading)\r\n                        {\r\n                            switch getComponentID(signature)\r\n                            {\r\n                                case Some(id):\r\n                                    switch resolved.toComplexType()\r\n                                    {\r\n                                        case TPath(tp): insert(id, macro new $tp());\r\n                                        case other: Context.error('Component $other should be TPath', component.pos);\r\n                                    }\r\n                                case None: Context.warning('Component $resolved is not used in any families', component.pos);\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            switch resolved.toComplexType()\r\n                            {\r\n                                case TPath(tp): insert(registerComponent(signature, resolved), macro new $tp());\r\n                                case other: Context.error('Component $other should be TPath', component.pos);\r\n                            }\r\n                        }\r\n                }\r\n            case _:\r\n                try\r\n                {\r\n                    final resolved  = Context.typeof(component);\r\n                    final signature = Utils.signature(resolved);\r\n\r\n                    switch getComponentID(signature)\r\n                    {\r\n                        case Some(id): insert(id, component);\r\n                        case None: Context.warning('Component ${ resolved } is not used in any families', component.pos);\r\n                    }\r\n                }\r\n                catch (_)\r\n                {\r\n                    Context.error('Unable to get type of component expression ${ component.toString() }', component.pos);\r\n                }\r\n        }\r\n    }\r\n\r\n    // After all `set` functions are called check each family which could have been modified by the components added.\r\n    exprs.push(macro final ecsEntCompFlags = $e{ _universe }.components.flags[_ecsTmpEntity.id()]);\r\n    if (staticLoading)\r\n    {\r\n        // With static loaded the `added` set contains all families which could have been effected by the components added.\r\n        // So we only need to check those ones.\r\n        for (familyID in added)\r\n        {\r\n            exprs.push(macro final ecsTmpFamily = $e{ _universe }.families.get($v{ familyID }));\r\n            exprs.push(macro if (ecsEntCompFlags.areSet(ecsTmpFamily.componentsMask)) {\r\n                ecsTmpFamily.add(_ecsTmpEntity);\r\n            });\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // With dynamic loaded we have no choice but to check all families.\r\n        exprs.push(macro for (i in 0...$e{ _universe }.families.number) {\r\n            final ecsTmpFamily = $e{ _universe }.families.get(i);\r\n            if (ecsEntCompFlags.areSet(ecsTmpFamily.componentsMask))\r\n            {\r\n                ecsTmpFamily.add(_ecsTmpEntity);\r\n            }\r\n        });\r\n    }\r\n\r\n    return macro $b{ exprs };\r\n}\r\n\r\n/**\r\n * Removes any number of components from an entity in a given universe.\r\n * The final argument is a rest argument meaning it can take in any number of arguments.\r\n * \r\n * Example usage for `using ecs.macros.UniverseMacros;`\r\n * \r\n * ```\r\n * universe.removeComponents(myEntity, Position, Velocity, Sprite);\r\n * ```\r\n * \r\n * Attempting to remove a component which is not used in any families will result in a compiler warning\r\n * and that expression will be skipped.\r\n * @param _universe Universe which contains the entity.\r\n * @param _entity Entity to remove components from.\r\n * @param _components Components to remove.\r\n */\r\nmacro function removeComponents(_universe : ExprOf<Universe>, _entity : Expr, _components : Array<Expr>)\r\n{\r\n    final staticLoading = Context.defined('ecs.static_loading');\r\n    final exprs         = [ macro final _ecsTmpEntity = $e{ _entity } ];\r\n    final added         = new Set();\r\n    final insert        = id -> {\r\n        exprs.push(macro $e{ _universe }.components.remove(_ecsTmpEntity, $v{ id }));\r\n\r\n        if (staticLoading)\r\n        {\r\n            for (familyID in getFamilyIDsWithComponent(id))\r\n            {\r\n                added.add(familyID);\r\n            }\r\n        }\r\n    };\r\n\r\n    for (component in _components)\r\n    {\r\n        switch component.expr\r\n        {\r\n            case EConst(CIdent(s)):\r\n                switch isLocalIdent(s, Context.getLocalType().getClass(), Context.getLocalTVars())\r\n                {\r\n                    case Some(type):\r\n                        switch getComponentID(Utils.signature(type))\r\n                        {\r\n                            case Some(id): insert(id);\r\n                            case None: Context.warning('Component ${ type } is not used in any families', component.pos);\r\n                        }\r\n                    case None:\r\n                        final resolved  = Context.getType(s);\r\n                        final signature = Utils.signature(resolved);\r\n\r\n                        switch getComponentID(signature)\r\n                        {\r\n                            case Some(id): insert(id);\r\n                            case None: Context.warning('Component ${ resolved } is not used in any families', component.pos);\r\n                        }\r\n                }\r\n            case _: Context.error('Unsupported component expression ${ component.toString() }', component.pos);\r\n        }\r\n    }\r\n\r\n    // After all `remove` functions are called check each family which could have been modified by the components removed.\r\n    exprs.push(macro final ecsEntCompFlags = $e{ _universe }.components.flags[_ecsTmpEntity.id()]);\r\n    if (staticLoading)\r\n    {\r\n        // With static loaded the `added` set contains all families which could have been effected by the components added.\r\n        // So we only need to check those ones.\r\n        for (familyID in added)\r\n        {\r\n            exprs.push(macro final ecsTmpFamily = $e{ _universe }.families.get($v{ familyID }));\r\n            exprs.push(macro if (!ecsEntCompFlags.areSet(ecsTmpFamily.componentsMask)) {\r\n                ecsTmpFamily.remove(_ecsTmpEntity);\r\n            });\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // With dynamic loaded we have no choice but to check all families.\r\n        exprs.push(macro for (i in 0...$e{ _universe }.families.number) {\r\n            final ecsTmpFamily = $e{ _universe }.families.get(i);\r\n            if (!ecsEntCompFlags.areSet(ecsTmpFamily.componentsMask))\r\n            {\r\n                ecsTmpFamily.add(_ecsTmpEntity);\r\n            }\r\n        });\r\n    }\r\n\r\n    return macro $b{ exprs };\r\n}\r\n\r\n/**\r\n * Add any number of resources to a given universe.\r\n * The final argument is a rest argument meaning it can take in any number of arguments.\r\n * \r\n * Example usage for `using ecs.macros.UniverseMacros;`\r\n * \r\n * ```\r\n * unverse.setResource(\r\n *     new LevelData('assets/level1.json'),\r\n *     new SpriteBatcher());\r\n * ```\r\n * \r\n * Along with the usual variable, function, and constructor expressions if the resource has a constructor\r\n * with no arguments then simply passing in the type will construct it.\r\n * \r\n * ```\r\n * universe.setResources(\r\n *     new LevelData('assets/level1.json'),\r\n *     SpriteBatcher);\r\n * ```\r\n * \r\n * It is also possible to use basic types for resources.\r\n * \r\n * ```\r\n * universe.setResources(7, 4.2, true, 'hello world');\r\n * ```\r\n * \r\n * Attempting to add a resource which is not used in any families will result in a compiler warning and that\r\n * expression will not be typed (no functions or property getters would be called if used).\r\n * Setting a resource which has already been set will replace.\r\n * @param _universe Universe to add resources to.\r\n * @param _resources Resources to add.\r\n */\r\nmacro function setResources(_universe : ExprOf<Universe>, _resources : Array<Expr>)\r\n{\r\n    final staticLoading = Context.defined('ecs.static_loading');\r\n    final exprs         = [];\r\n    final added         = new Set();\r\n    final insert        = (id, resExpr) -> {\r\n        exprs.push(macro $e{ _universe }.resources.insert($v{ id }, $e{ resExpr }));\r\n\r\n        if (staticLoading)\r\n        {\r\n            for (familyID in getFamilyIDsWithResource(id))\r\n            {\r\n                added.add(familyID);\r\n            }   \r\n        }\r\n    };\r\n\r\n    for (resource in _resources)\r\n    {\r\n        switch resource.expr\r\n        {\r\n            case EConst(CIdent(s)):\r\n                switch isLocalIdent(s, Context.getLocalType().getClass(), Context.getLocalTVars())\r\n                {\r\n                    case Some(type):\r\n                        insert(registerResource(Utils.signature(type)), resource);\r\n                    case None:\r\n                        final resolved  = Context.getType(s);\r\n                        final signature = Utils.signature(resolved);\r\n                        final id        = registerResource(signature);\r\n\r\n                        switch resolved.toComplexType()\r\n                        {\r\n                            case TPath(tp): insert(id, macro new $tp());\r\n                            case other: Context.error('Resource $other should be TPath', resource.pos);\r\n                        }\r\n                }\r\n            case _:\r\n                try\r\n                {\r\n                    final resolved  = Context.typeof(resource);\r\n                    final signature = Utils.signature(resolved);\r\n                    final id        = registerResource(signature);\r\n\r\n                    insert(id, resource);\r\n                }\r\n                catch (_)\r\n                {\r\n                    Context.error('Unable to get type of resource expression $resource', resource.pos);\r\n                }\r\n        }\r\n    }\r\n\r\n    // Add a call to try and activate each families which requested the resources.\r\n    // If we are not dynamically loading we can reduced the number of families we try and activate\r\n    // When dynamically loading we have no choice by to try and load each family.\r\n    if (staticLoading)\r\n    {\r\n        for (familyID in added)\r\n        {\r\n            exprs.push(macro $e{ _universe }.families.tryActivate($v{ familyID }));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        exprs.push(macro for (i in 0...$e{ _universe }.families.number) $e{ _universe }.families.tryActivate(i));\r\n    }\r\n\r\n    return macro $b{ exprs };\r\n}\r\n\r\n/**\r\n * Removes any number of resource from the given universe.\r\n * The final argument is a rest argument meaning it can take in any number of arguments.\r\n * \r\n * Example usage for `using ecs.macros.UniverseMacros;`\r\n * \r\n * ```\r\n * universe.removeResources(LevelData, SpriteBatcher);\r\n * ```\r\n * \r\n * Attempting to remove a resource which is not used in any families will result in a compiler warning\r\n * and that expression will be skipped.\r\n * @param _universe Universe to remove the resource from.\r\n * @param _components Resources to remove.\r\n */\r\nmacro function removeResources(_universe : ExprOf<Universe>, _resources : Array<Expr>)\r\n{\r\n    final staticLoading = Context.defined('ecs.static_loading');\r\n    final exprs         = [];\r\n    final adder         = new Set();\r\n    final insert        = id -> {\r\n        adder.add(id);\r\n\r\n        if (staticLoading)\r\n        {\r\n            for (familyID in getFamilyIDsWithResource(id))\r\n            {\r\n                exprs.push(macro $e{ _universe }.families.get($v{ familyID }).deactivate());\r\n            }\r\n        }\r\n    };\r\n\r\n    for (resource in _resources)\r\n    {\r\n        switch resource.expr\r\n        {\r\n            case EConst(CIdent(s)):\r\n                switch isLocalIdent(s, Context.getLocalType().getClass(), Context.getLocalTVars())\r\n                {\r\n                    case Some(type):\r\n                        switch getResourceID(Utils.signature(type))\r\n                        {\r\n                            case Some(id): insert(id);\r\n                            case None: Context.warning('Resource $type is not used in any families', resource.pos);\r\n                        }\r\n                    case None:\r\n                        final resolved  = Context.getType(s);\r\n                        final signature = Utils.signature(resolved);\r\n\r\n                        switch getResourceID(signature)\r\n                        {\r\n                            case Some(id):\r\n                                switch resolved.toComplexType()\r\n                                {\r\n                                    case TPath(_): insert(id);\r\n                                    case other:\r\n                                }\r\n                            case None: Context.warning('Resource $resolved is not used in any families', resource.pos);\r\n                        }\r\n                }\r\n            case _:\r\n                Context.error('Unsupported resource expression ${ resource.toString() }', resource.pos);\r\n        }\r\n    }\r\n\r\n    // Remove the resources once each family has been deactivated\r\n    for (resourceID in adder)\r\n    {\r\n        if (!staticLoading)\r\n        {\r\n            exprs.push(macro for (i in 0...$e{ _universe }.families.number) $e{ _universe }.families.tryDeactivate(i, $v{ resourceID }));\r\n        }\r\n\r\n        exprs.push(macro $e{ _universe }.resources.remove($v{ resourceID }));\r\n    }\r\n\r\n    return macro $b{ exprs };\r\n}\r\n\r\n/**\r\n * Add any number of systems to be ran by the provided universe.\r\n * The final argument is a rest argument meaning it can take in any number of arguments.\r\n * \r\n * Example usage for `using ecs.macros.UniverseMacros;`\r\n * \r\n * ```\r\n * unverse.setSystems(\r\n *     new VelocitySystem(),\r\n *     new SpriteDrawingSystem());\r\n * ```\r\n * \r\n * Along with the usual variable, function, and constructor expressions if the system does not have a custom\r\n * constructor you can provide just the type and it will be constructed for you.\r\n * \r\n * ```\r\n * universe.setSystems(\r\n *     new VelocitySystem(),\r\n *     SpriteDrawingSystem);\r\n * ```\r\n * \r\n * Systems are updated in the order they were added, and adding the same system to the universe twice will cause it\r\n * to be updated twice on every universe update.\r\n * @param _universe Universe to add systems to.\r\n * @param _systems Systems to add.\r\n */\r\nmacro function setSystems(_universe : ExprOf<Universe>, _systems : Array<Expr>)\r\n{\r\n    final exprs = [];\r\n\r\n    for (system in _systems)\r\n    {\r\n        switch system.expr\r\n        {\r\n            case EConst(CIdent(s)):\r\n                // Systems don't have unique IDs so we pass a function which will always return 0.\r\n                // This way we can still use the same resolution logic\r\n                switch isLocalIdent(s, Context.getLocalType().getClass(), Context.getLocalTVars())\r\n                {\r\n                    case Some(_):\r\n                        exprs.push(macro $e{ _universe }.systems.add($e{ system }));\r\n                    case None:\r\n                        switch Context.getType(s).toComplexType()\r\n                        {\r\n                            case TPath(tp): exprs.push(macro $e{ _universe }.systems.add(new $tp($e{ _universe })));\r\n                            case other: Context.error('System $other should be TPath', system.pos);\r\n                        }\r\n                }\r\n            case ENew(tp, _):\r\n                exprs.push(macro $e{ _universe }.systems.add($e{ system }));\r\n            case _:\r\n                Context.error('Unsupported system expression ${ system }', system.pos);\r\n        }\r\n    }\r\n\r\n    return macro $b{ exprs };\r\n}\r\n\r\n/**\r\n * Remove any number of systems from the provided universe.\r\n * The final argument is a rest argument meaning it can take in any number of arguments.\r\n * \r\n * Example usage for `using ecs.macros.UniverseMacros;`\r\n * \r\n * ```\r\n * unverse.removeSystems(\r\n *     someField,\r\n *     functionWhichReturnsSomeSystem());\r\n * ```\r\n * \r\n * The system expressions must refer to a system object, as currently systems do not have a unique ID.\r\n * \r\n * @param _universe Universe to remove systems from.\r\n * @param _systems fields pointing to system objects to remove.\r\n */\r\nmacro function removeSystems(_universe : ExprOf<Universe>, _systems : Array<Expr>)\r\n{\r\n    final exprs = [];\r\n\r\n    for (system in _systems)\r\n    {\r\n        switch system.expr\r\n        {\r\n            case EConst(CIdent(s)):\r\n                switch isLocalIdent(s, Context.getLocalType().getClass(), Context.getLocalTVars())\r\n                {\r\n                    case Some(_):\r\n                        exprs.push(macro $e{ _universe }.systems.remove($e{ system }));\r\n                    case None:\r\n                        Context.error('Only expressions which reference a system object can be used to remove a system', system.pos);\r\n                }\r\n            case _: Context.error('Only expressions which reference a system object can be used to remove a system', system.pos);\r\n        }\r\n    }\r\n\r\n    return macro $b{ exprs };\r\n}\r\n\r\n/**\r\n * The setup macro function checks if all the resources requested by the provided families are available,\r\n * if they are it creates local variables for each resource with the specified name and runs the provided code block.\r\n * \r\n * ```\r\n * setup(someFamily, {\r\n *     // code will only be ran if all of the resources requested by `someFamily` are available.\r\n * });\r\n * ```\r\n * \r\n * This macro function cannot be used when importing the `UniverseMacros` module for static extension use.\r\n * @param _families Either a family definition variable or an array of family definition variables. \r\n * @param _function Code to execute if all the families are active.\r\n */\r\nmacro function setup(_families : ExprOf<Family>, _function : Expr)\r\n{\r\n    final familiesToSetup = switch _families.expr\r\n    {\r\n        case EConst(CIdent(s)): [ s ];\r\n        case EArrayDecl(values): [ for (e in values) switch e.expr {\r\n            case EConst(CIdent(s)): s;\r\n            case _: Context.error('Family should be an identifier', e.pos);\r\n        } ];\r\n        case _: Context.error('Families to setup must be an identifier or an array of identifiers', _families.pos);\r\n    }\r\n    final extracted = switch _function.expr\r\n    {\r\n        case EFunction(_, f):\r\n            switch extractFunctionBlock(f.expr)\r\n            {\r\n                case Some(v): v;\r\n                case None: Context.error('Unable to extract EBlock from function', f.expr.pos);\r\n            }\r\n        case EBlock(exprs):\r\n            exprs;\r\n        case other:\r\n            Context.error('Unsupported iterate expression $other', _function.pos);\r\n    };\r\n    \r\n    // Insert variable declarations to the top of the extracted function block.\r\n    // TODO : should probably check to make sure there are no type or name collisions.\r\n    for (ident in familiesToSetup)\r\n    {\r\n        final clsKey = '${ Utils.signature(Context.getLocalType()) }-${ ident }';\r\n        switch getFamilyByKey(clsKey)\r\n        {\r\n            case Some(family):\r\n\r\n                for (resource in family.resources)\r\n                {\r\n                    if (resource.name != '_')\r\n                    {\r\n                        final signature = Utils.signature(resource.type);\r\n                        final ct        = resource.type.toComplexType();\r\n                        final varName   = resource.name;\r\n\r\n                        switch getResourceID(signature)\r\n                        {\r\n                            case Some(id):\r\n                                extracted.insert(0, macro final $varName = (universe.resources.get($v{ id }) : $ct));\r\n                            case None:\r\n                                Context.error('Resource ${ resource.type } has not been requested by any families', _families.pos);\r\n                        }\r\n                    }\r\n                }\r\n            case None: Context.error('Unable to find a family with the key $clsKey', _families.pos);\r\n        }\r\n    }\r\n\r\n    // Build up the if check for all the of families\r\n    var idx  = familiesToSetup.length - 1;\r\n    var expr = macro $i{ familiesToSetup[idx] }.isActive();\r\n\r\n    while (idx > 0)\r\n    {\r\n        idx--;\r\n\r\n        expr = macro $e{ expr } && $i{ familiesToSetup[idx] }.isActive();\r\n    }\r\n\r\n    return macro if ($e{ expr }) $b{ extracted };\r\n}\r\n\r\n/**\r\n * The iterate macro is the main way to execute code with each entities components in a given family,\r\n * it automates the process of getting the components using the names provided when defining the family.\r\n * In situations where you don't actually care about the entity itself you can use it in the following way.\r\n * \r\n * ```\r\n * iterate(someFamily, {\r\n *     // code here is ran for each entity found in `someFamily`.\r\n * });\r\n * ```\r\n * Alternatively lambda function syntax can be used.\r\n * ```\r\n * iterate(someFamily, () -> {\r\n *     // code here is ran for each entity found in `someFamily`.\r\n * });\r\n * ```\r\n * If you do need to access the entity whos components are currently being accessed then you can use lambda function\r\n * syntax with a single parameter which will then be accessible in the block and contain the current entity.\r\n * ```\r\n * iterate(someFamily, entity -> {\r\n *     // `entity` is the entity which has the components currently being accessed.\r\n * });\r\n * ```\r\n * It is perfectly valid to nest iterate calls as long as there are no component identifier collisions in any of the\r\n * nested function iterations.\r\n * \r\n * This macro function cannot be used when importing the `UniverseMacros` module for static extension use.\r\n * @param _family Family to iterate over.\r\n * @param _function Code to run for each entity in the family.\r\n */\r\nmacro function iterate(_family : ExprOf<Family>, _function : Expr)\r\n{\r\n    // Get the name of the family to iterate over.\r\n    final familyIdent = switch _family.expr\r\n    {\r\n        case EConst(CIdent(s)): s;\r\n        case _: Context.error('Family passed into iterate must be an identifier', _family.pos);\r\n    }\r\n\r\n    // Extract the name of the entity variable in each iteration and the user typed expressions for the loop.\r\n    final extracted = switch _function.expr\r\n    {\r\n        case EFunction(_, f):\r\n            {\r\n                name : if (f.args.length == 0) '_tmpEnt' else f.args[0].name,\r\n                expr : switch extractFunctionBlock(f.expr)\r\n                {\r\n                    case Some(v): v;\r\n                    case None: Context.error('Unable to extract EBlock from function', f.expr.pos);\r\n                }\r\n            };\r\n        case EBlock(exprs):\r\n            { name : '_tmpEnt', expr : exprs };\r\n        case other:\r\n            Context.error('Unsupported iterate expression $other', _function.pos);\r\n    }\r\n\r\n    // Based on the family name and this systems name search all registered families for a match\r\n    final clsKey     = '${ Utils.signature(Context.getLocalType()) }-${ familyIdent }';\r\n    final components = switch getFamilyByKey(clsKey)\r\n    {\r\n        case Some(family): family.components;\r\n        case None: Context.error('Unable to find a family with the key $clsKey', _family.pos);\r\n    }\r\n\r\n    // Generate a local variable with the requested name for each component in the family.\r\n    // Then append the user typed for loop expression to ensure the variables are always accessible\r\n    final forExpr = [];\r\n    for (c in components)\r\n    {\r\n        final varName   = c.name;\r\n        final tableName = 'table${ c.hash }';\r\n        final ct        = c.type.toComplexType();\r\n\r\n        // Defining a component in a family as '_' will skip the variable generation.\r\n        if (varName != '_')\r\n        {\r\n            forExpr.push(macro @:pos(Context.currentPos()) final $varName = ($i{ tableName }.get($i{ extracted.name }) : $ct));\r\n        }\r\n    }\r\n    for (e in extracted.expr)\r\n    {\r\n        forExpr.push(e);\r\n    }\r\n\r\n    return macro @:pos(Context.currentPos()) for ($i{ extracted.name } in $e{ _family }) $b{ forExpr };\r\n}\r\n\r\n/**\r\n * Returns the table variable for a specific component type.\r\n * This should not be used outside of a system.\r\n * If the provided type is not used as a component in any of the systems families the behaviour is undefined.\r\n * \r\n * ```\r\n * final component = table(SomeComponent).get(entity);\r\n * ```\r\n * @param _type Type to get the table for.\r\n */\r\nmacro function table(_type : ExprOf<TableType>)\r\n{\r\n    return switch _type.expr\r\n    {\r\n        case EConst(CIdent(s)):\r\n            final resolved  = Context.getType(s);\r\n            final signature = Utils.signature(resolved);\r\n\r\n            { expr : EConst(CIdent('table$signature')), pos : Context.currentPos() };\r\n        case _:\r\n            Context.error('Argument must be a type identifier', Context.currentPos());\r\n    }\r\n}\r\n\r\n/**\r\n * Given an expression it will try and extract the EBlock expressions acting as if it is a function expression.\r\n * It expects an `EMeta(EReturn(EBlock))` expression three.\r\n * @param _expr Expression to operate on.\r\n * @return Option<Array<Expr>>\r\n */\r\nprivate function extractFunctionBlock(_expr : Expr) : Option<Array<Expr>>\r\n{\r\n    return switch _expr.expr\r\n    {\r\n        case EMeta(_, { expr : EReturn({ expr : EBlock(exprs) }) }):\r\n            Some(exprs);\r\n        case _:\r\n            None;\r\n    }\r\n}\r\n\r\n/**\r\n * Given an identified string, class type, and local variables it will return the type of the identified if it exists in the class or local variables.\r\n * @param _target Identifier string.\r\n * @param _classType Class type to check local and static variables.\r\n * @param _vars Map of local variables to check.\r\n * @return Option<haxe.macro.Type>\r\n */\r\nprivate function isLocalIdent(_target : String, _classType : ClassType, _vars : Map<String, TVar>) : Option<haxe.macro.Type>\r\n{\r\n    final found = _classType.findField(_target).or(_classType.findField(_target, true));\r\n\r\n    if (found != null)\r\n    {\r\n        return Some(found.type);\r\n    }\r\n\r\n    return if (_vars.exists(_target))\r\n    {\r\n        Some(_vars.get(_target).unsafe().t);\r\n    }\r\n    else\r\n    {\r\n        None;\r\n    }\r\n}\r\n\r\nabstract TableType(String) from String to String {\r\n\tfunction new(value) {\r\n\t\t this = value;\r\n\t}\r\n\t\r\n\t@:from static function fromClass(input:Class<Dynamic>) {\r\n\t\t return new TableType(Type.getClassName(input));\r\n\t}\r\n }\r\n","#if macro\nimport haxe.macro.Context;\nimport safety.macro.SafeAst;\n#end\n\nclass Safety {\n\n\t/**\n\t *  Returns `value` if it is not `null`. Otherwise returns `defaultValue`.\n\t */\n\tstatic public inline function or<T>(value:Null<T>, defaultValue:T):T {\n\t\treturn value == null ? defaultValue : @:nullSafety(Off) (value:T);\n\t}\n\n\t/**\n\t *  Returns `value` if it is not `null`. Otherwise calls `getter` and returns the result.\n\t */\n\tstatic public inline function orGet<T>(value:Null<T>, getter:Void->T):T {\n\t\treturn value == null ? getter() : @:nullSafety(Off) (value:T);\n\t}\n\n\t/**\n\t *  Returns `value` if it is not `null`. Otherwise throws an exception.\n\t *  @throws NullPointerException if `value` is `null`.\n\t */\n\tstatic public inline function sure<T>(value:Null<T>):T {\n\t\treturn value == null ? throw new safety.NullPointerException('Null pointer in .sure() call') : @:nullSafety(Off) (value:T);\n\t}\n\n\t/**\n\t *  Just returns `value` without any checks, but typed as not-nullable. Use at your own risk.\n\t */\n\tstatic public inline function unsafe<T>(value:Null<T>):T {\n\t\treturn @:nullSafety(Off) (value:T);\n\t}\n\n\t/**\n\t *  Returns `true` if value is not null and `callback(value)` is evaluated to `true`.\n\t *  Returns `false` otherwise.\n\t */\n\tstatic public inline function check<T>(value:Null<T>, callback:T->Bool):Bool {\n\t\treturn value != null && callback(@:nullSafety(Off) (value:T));\n\t}\n\n\t/**\n\t *  Applies `callback` to `value` and returns the result if `value` is not `null`.\n\t *  Returns `null` otherwise.\n\t */\n\tstatic public inline function let<T,V>(value:Null<T>, callback:T->V):Null<V> {\n\t\treturn value == null ? null : callback(@:nullSafety(Off) (value:T));\n\t}\n\n\t/**\n\t *  Passes `value` to `callback` if `value` is not null.\n\t */\n\tstatic public inline function run<T>(value:Null<T>, callback:T->Void) {\n\t\tif(value != null) callback(@:nullSafety(Off) (value:T));\n\t}\n\n\t/**\n\t *  Applies `callback` to `value` if `value` is not `null`.\n\t *  Returns `value`.\n\t */\n\tstatic public inline function apply<T>(value:Null<T>, callback:T->Void):Null<T> {\n\t\tswitch(value) {\n\t\t\tcase null:\n\t\t\tcase _: callback(@:nullSafety(Off) (value:T));\n\t\t}\n\t\treturn value;\n\t}\n\n#if macro\n\n\t/**\n\t *  Add this call to hxml to make public methods in specified `path` to throw `NullPointerException`\n\t *  if someone passes `null` as an argument value and that argument is not nullable.\n\t *  ```\n\t *  public function job(str:String) {...}\n\t *  <...>\n\t *  job(null); //throws safety.NullPointerException\n\t *  ```\n\t *  Example for hxml:\n\t *  ```\n\t *  --macro Safety.safeApi('my.pack', true)\n\t *  ```\n\t *  @param path - Dot-path of a package or a fully qualified type name.\n\t *  @param recursive - Should we also apply to all sub-packages of `path`?\n\t */\n\tstatic public function safeApi(path:String, recursive:Bool = true) {\n\t\tSafeAst.addSafeApi(path, recursive);\n\t}\n\n\t/**\n\t *  Add this call to hxml to enable safe navigation operator `!.`:\n\t *  ```\n\t *  var s:Null<String> = null;\n\t *  trace(s!.length); //null\n\t *  s = 'wow';\n\t *  trace(s!.length); //3\n\t *  ```\n\t *  Example for hxml:\n\t *  ```\n\t *  --macro Safety.safeNavigation('my.pack', true)\n\t *  ```\n\t *  @param path - Dot-path of a package or a fully qualified type name.\n\t *  @param recursive - Should we also apply to all sub-packages/sub-types of `path`?\n\t */\n\tstatic public function safeNavigation(path:String, recursive:Bool = true) {\n\t\tSafeAst.addSafeNavigation(path, recursive);\n\t}\n\n\t/**\n\t *  Add this call to hxml to enable auto-casting all array declarations to `SafeArray`:\n\t *  Example for hxml:\n\t *  ```\n\t *  --macro Safety.safeArray('my.pack', true)\n\t *  ```\n\t *  @param path - Dot-path of a package or a fully qualified type name.\n\t *  @param recursive - Should we also apply to all sub-packages/sub-types of `path`?\n\t */\n\tstatic public function safeArray(path:String, recursive:Bool = true) {\n\t\tSafeAst.addSafeArray(path, recursive);\n\t}\n\n\t/**\n\t * Check if compilation is running in display mode.\n\t */\n\t@:allow(safety)\n\tstatic function isDisplay():Bool {\n\t\t#if display\n\t\t\treturn true;\n\t\t#end\n\t\treturn Context.defined('display');\n\t}\n#end\n}","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nimport js.Boot;\r\nimport js.Syntax;\r\n\r\n@:keepInit\r\n@:coreApi class Std {\r\n\t@:deprecated('Std.is is deprecated. Use Std.isOfType instead.')\r\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\r\n\t\treturn isOfType(v, t);\r\n\t}\r\n\r\n\tpublic static inline function isOfType(v:Dynamic, t:Dynamic):Bool {\r\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\r\n\t}\r\n\r\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\r\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\r\n\t}\r\n\r\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\r\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\r\n\t\treturn downcast(value, c);\r\n\t}\r\n\r\n\t@:pure\r\n\tpublic static function string(s:Dynamic):String {\r\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\r\n\t}\r\n\r\n\tpublic static inline function int(x:Float):Int {\r\n\t\treturn (cast x) | 0;\r\n\t}\r\n\r\n\t@:pure\r\n\tpublic static function parseInt(x:String):Null<Int> {\r\n\t\tif(x != null) {\r\n\t\t\tfor(i in 0...x.length) {\r\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\r\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\r\n\t\t\t\t\tvar nc = StringTools.fastCodeAt(x, i + 1);\r\n\t\t\t\t\tvar v = js.Lib.parseInt(x, (nc == \"x\".code || nc == \"X\".code) ? 16 : 10);\r\n\t\t\t\t\treturn Math.isNaN(v) ? null : cast v;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic static inline function parseFloat(x:String):Float {\r\n\t\treturn js.Syntax.code(\"parseFloat({0})\", x);\r\n\t}\r\n\r\n\tpublic static function random(x:Int):Int {\r\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\r\n\t}\r\n\r\n\tstatic function __init__():Void\r\n\t\tuntyped {\r\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\r\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\r\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\r\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\r\n\t\t\t__feature__(\"Date.*\", {\r\n\t\t\t\t__feature__(\"js.Boot.getClass\",\r\n\t\t\t\t\tjs.Syntax.code('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = js.Syntax.code('Date'), js.Syntax.code('Date')));\r\n\t\t\t\t__feature__(\"js.Boot.isClass\", js.Syntax.code('Date').__name__ = \"Date\");\r\n\t\t\t});\r\n\t\t\t__feature__(\"Int.*\", js.Syntax.code('var Int = { };'));\r\n\t\t\t__feature__(\"Dynamic.*\", js.Syntax.code('var Dynamic = { };'));\r\n\t\t\t__feature__(\"Float.*\", js.Syntax.code('var Float = Number'));\r\n\t\t\t__feature__(\"Bool.*\", js.Syntax.code('var Bool = Boolean'));\r\n\t\t\t__feature__(\"Class.*\", js.Syntax.code('var Class = { };'));\r\n\t\t\t__feature__(\"Enum.*\", js.Syntax.code('var Enum = { };'));\r\n\t\t\t#if (js_es < 5)\r\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\r\n\t\t\t\tvar a = [];\r\n\t\t\t\tfor (i in 0...__this__.length)\r\n\t\t\t\t\ta[i] = f(__this__[i]);\r\n\t\t\t\treturn a;\r\n\t\t\t});\r\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\r\n\t\t\t\tvar a = [];\r\n\t\t\t\tfor (i in 0...__this__.length) {\r\n\t\t\t\t\tvar e = __this__[i];\r\n\t\t\t\t\tif (f(e))\r\n\t\t\t\t\t\ta.push(e);\r\n\t\t\t\t}\r\n\t\t\t\treturn a;\r\n\t\t\t});\r\n\t\t\t#end\r\n\t\t}\r\n}\r\n","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nimport haxe.iterators.StringIterator;\r\nimport haxe.iterators.StringKeyValueIterator;\r\n\r\n#if cpp\r\nusing cpp.NativeString;\r\n#end\r\n\r\n/**\r\n\tThis class provides advanced methods on Strings. It is ideally used with\r\n\t`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\r\n\tto the `String` class.\r\n\r\n\tIf the first argument to any of the methods is null, the result is\r\n\tunspecified.\r\n**/\r\nclass StringTools {\r\n\t/**\r\n\t\tEncode an URL by using the standard format.\r\n\t**/\r\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlEncode(s:String):String {\r\n\t\t#if flash\r\n\t\treturn untyped __global__[\"encodeURIComponent\"](s);\r\n\t\t#elseif neko\r\n\t\treturn untyped new String(_urlEncode(s.__s));\r\n\t\t#elseif js\r\n\t\treturn untyped encodeURIComponent(s);\r\n\t\t#elseif cpp\r\n\t\treturn untyped s.__URLEncode();\r\n\t\t#elseif java\r\n\t\treturn postProcessUrlEncode(java.net.URLEncoder.encode(s, \"UTF-8\"));\r\n\t\t#elseif cs\r\n\t\treturn untyped cs.system.Uri.EscapeDataString(s);\r\n\t\t#elseif python\r\n\t\treturn python.lib.urllib.Parse.quote(s, \"\");\r\n\t\t#elseif hl\r\n\t\tvar len = 0;\r\n\t\tvar b = @:privateAccess s.bytes.urlEncode(len);\r\n\t\treturn @:privateAccess String.__alloc__(b, len);\r\n\t\t#elseif lua\r\n\t\ts = lua.NativeStringTools.gsub(s, \"\\n\", \"\\r\\n\");\r\n\t\ts = lua.NativeStringTools.gsub(s, \"([^%w %-%_%.%~])\", function(c) {\r\n\t\t\treturn lua.NativeStringTools.format(\"%%%02X\", lua.NativeStringTools.byte(c) + '');\r\n\t\t});\r\n\t\ts = lua.NativeStringTools.gsub(s, \" \", \"+\");\r\n\t\treturn s;\r\n\t\t#else\r\n\t\treturn null;\r\n\t\t#end\r\n\t}\r\n\r\n\t#if java\r\n\tprivate static function postProcessUrlEncode(s:String):String {\r\n\t\tvar ret = new StringBuf();\r\n\t\tvar i = 0, len = s.length;\r\n\t\twhile (i < len) {\r\n\t\t\tswitch (_charAt(s, i++)) {\r\n\t\t\t\tcase '+'.code:\r\n\t\t\t\t\tret.add('%20');\r\n\t\t\t\tcase '%'.code if (i <= len - 2):\r\n\t\t\t\t\tvar c1 = _charAt(s, i++), c2 = _charAt(s, i++);\r\n\t\t\t\t\tswitch [c1, c2] {\r\n\t\t\t\t\t\tcase ['2'.code, '1'.code]:\r\n\t\t\t\t\t\t\tret.addChar('!'.code);\r\n\t\t\t\t\t\tcase ['2'.code, '7'.code]:\r\n\t\t\t\t\t\t\tret.addChar('\\''.code);\r\n\t\t\t\t\t\tcase ['2'.code, '8'.code]:\r\n\t\t\t\t\t\t\tret.addChar('('.code);\r\n\t\t\t\t\t\tcase ['2'.code, '9'.code]:\r\n\t\t\t\t\t\t\tret.addChar(')'.code);\r\n\t\t\t\t\t\tcase ['7'.code, 'E'.code] | ['7'.code, 'e'.code]:\r\n\t\t\t\t\t\t\tret.addChar('~'.code);\r\n\t\t\t\t\t\tcase _:\r\n\t\t\t\t\t\t\tret.addChar('%'.code);\r\n\t\t\t\t\t\t\tret.addChar(cast c1);\r\n\t\t\t\t\t\t\tret.addChar(cast c2);\r\n\t\t\t\t\t}\r\n\t\t\t\tcase var chr:\r\n\t\t\t\t\tret.addChar(cast chr);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret.toString();\r\n\t}\r\n\t#end\r\n\r\n\t/**\r\n\t\tDecode an URL using the standard format.\r\n\t**/\r\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlDecode(s:String):String {\r\n\t\t#if flash\r\n\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\r\n\t\t#elseif neko\r\n\t\treturn untyped new String(_urlDecode(s.__s));\r\n\t\t#elseif js\r\n\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\r\n\t\t#elseif cpp\r\n\t\treturn untyped s.__URLDecode();\r\n\t\t#elseif java\r\n\t\ttry\r\n\t\t\treturn java.net.URLDecoder.decode(s, \"UTF-8\")\r\n\t\tcatch (e:Dynamic)\r\n\t\t\tthrow e;\r\n\t\t#elseif cs\r\n\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\r\n\t\t#elseif python\r\n\t\treturn python.lib.urllib.Parse.unquote(s);\r\n\t\t#elseif hl\r\n\t\tvar len = 0;\r\n\t\tvar b = @:privateAccess s.bytes.urlDecode(len);\r\n\t\treturn @:privateAccess String.__alloc__(b, len);\r\n\t\t#elseif lua\r\n\t\ts = lua.NativeStringTools.gsub(s, \"+\", \" \");\r\n\t\ts = lua.NativeStringTools.gsub(s, \"%%(%x%x)\", function(h) {\r\n\t\t\treturn lua.NativeStringTools.char(lua.Lua.tonumber(h, 16));\r\n\t\t});\r\n\t\ts = lua.NativeStringTools.gsub(s, \"\\r\\n\", \"\\n\");\r\n\t\treturn s;\r\n\t\t#else\r\n\t\treturn null;\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tEscapes HTML special characters of the string `s`.\r\n\r\n\t\tThe following replacements are made:\r\n\r\n\t\t- `&` becomes `&amp`;\r\n\t\t- `<` becomes `&lt`;\r\n\t\t- `>` becomes `&gt`;\r\n\r\n\t\tIf `quotes` is true, the following characters are also replaced:\r\n\r\n\t\t- `\"` becomes `&quot`;\r\n\t\t- `'` becomes `&#039`;\r\n\t**/\r\n\tpublic static function htmlEscape(s:String, ?quotes:Bool):String {\r\n\t\tvar buf = new StringBuf();\r\n\t\tfor (code in #if neko iterator(s) #else new haxe.iterators.StringIteratorUnicode(s) #end) {\r\n\t\t\tswitch (code) {\r\n\t\t\t\tcase '&'.code:\r\n\t\t\t\t\tbuf.add(\"&amp;\");\r\n\t\t\t\tcase '<'.code:\r\n\t\t\t\t\tbuf.add(\"&lt;\");\r\n\t\t\t\tcase '>'.code:\r\n\t\t\t\t\tbuf.add(\"&gt;\");\r\n\t\t\t\tcase '\"'.code if (quotes):\r\n\t\t\t\t\tbuf.add(\"&quot;\");\r\n\t\t\t\tcase '\\''.code if (quotes):\r\n\t\t\t\t\tbuf.add(\"&#039;\");\r\n\t\t\t\tcase _:\r\n\t\t\t\t\tbuf.addChar(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}\r\n\r\n\t/**\r\n\t\tUnescapes HTML special characters of the string `s`.\r\n\r\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\r\n\t\tholds: `htmlUnescape(htmlEscape(s)) == s`\r\n\r\n\t\tThe replacements follow:\r\n\r\n\t\t- `&amp;` becomes `&`\r\n\t\t- `&lt;` becomes `<`\r\n\t\t- `&gt;` becomes `>`\r\n\t\t- `&quot;` becomes `\"`\r\n\t\t- `&#039;` becomes `'`\r\n\t**/\r\n\tpublic static function htmlUnescape(s:String):String {\r\n\t\treturn s.split(\"&gt;\")\r\n\t\t\t.join(\">\")\r\n\t\t\t.split(\"&lt;\")\r\n\t\t\t.join(\"<\")\r\n\t\t\t.split(\"&quot;\")\r\n\t\t\t.join('\"')\r\n\t\t\t.split(\"&#039;\")\r\n\t\t\t.join(\"'\")\r\n\t\t\t.split(\"&amp;\")\r\n\t\t\t.join(\"&\");\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns `true` if `s` contains `value` and  `false` otherwise.\r\n\r\n\t\tWhen `value` is `null`, the result is unspecified.\r\n\t**/\r\n\tpublic static inline function contains(s:String, value:String):Bool {\r\n\t\t#if (js && js_es >= 6)\r\n\t\treturn (cast s).includes(value);\r\n\t\t#else \r\n\t\treturn s.indexOf(value) != -1;\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tTells if the string `s` starts with the string `start`.\r\n\r\n\t\tIf `start` is `null`, the result is unspecified.\r\n\r\n\t\tIf `start` is the empty String `\"\"`, the result is true.\r\n\t**/\r\n\tpublic static #if (cs || java || python || (js && js_es >= 6)) inline #end function startsWith(s:String, start:String):Bool {\r\n\t\t#if java\r\n\t\treturn (cast s : java.NativeString).startsWith(start);\r\n\t\t#elseif cs\r\n\t\treturn untyped s.StartsWith(start);\r\n\t\t#elseif hl\r\n\t\treturn @:privateAccess (s.length >= start.length && s.bytes.compare(0, start.bytes, 0, start.length << 1) == 0);\r\n\t\t#elseif python\r\n\t\treturn python.NativeStringTools.startswith(s, start);\r\n\t\t#elseif (js && js_es >= 6)\r\n\t\treturn (cast s).startsWith(start);\r\n\t\t#else\r\n\t\treturn (s.length >= start.length && s.lastIndexOf(start, 0) == 0);\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tTells if the string `s` ends with the string `end`.\r\n\r\n\t\tIf `end` is `null`, the result is unspecified.\r\n\r\n\t\tIf `end` is the empty String `\"\"`, the result is true.\r\n\t**/\r\n\tpublic static #if (cs || java || python || (js && js_es >= 6)) inline #end function endsWith(s:String, end:String):Bool {\r\n\t\t#if java\r\n\t\treturn (cast s : java.NativeString).endsWith(end);\r\n\t\t#elseif cs\r\n\t\treturn untyped s.EndsWith(end);\r\n\t\t#elseif hl\r\n\t\tvar elen = end.length;\r\n\t\tvar slen = s.length;\r\n\t\treturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\r\n\t\t#elseif python\r\n\t\treturn python.NativeStringTools.endswith(s, end);\r\n\t\t#elseif (js && js_es >= 6)\r\n\t\treturn (cast s).endsWith(end);\r\n\t\t#else\r\n\t\tvar elen = end.length;\r\n\t\tvar slen = s.length;\r\n\t\treturn (slen >= elen && s.indexOf(end, (slen - elen)) == (slen - elen));\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tTells if the character in the string `s` at position `pos` is a space.\r\n\r\n\t\tA character is considered to be a space character if its character code\r\n\t\tis 9,10,11,12,13 or 32.\r\n\r\n\t\tIf `s` is the empty String `\"\"`, or if pos is not a valid position within\r\n\t\t`s`, the result is false.\r\n\t**/\r\n\tpublic static function isSpace(s:String, pos:Int):Bool {\r\n\t\t#if (python || lua)\r\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length)\r\n\t\t\treturn false;\r\n\t\t#end\r\n\t\tvar c = s.charCodeAt(pos);\r\n\t\treturn (c > 8 && c < 14) || c == 32;\r\n\t}\r\n\r\n\t/**\r\n\t\tRemoves leading space characters of `s`.\r\n\r\n\t\tThis function internally calls `isSpace()` to decide which characters to\r\n\t\tremove.\r\n\r\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\r\n\t\tresult is the empty String `\"\"`.\r\n\t**/\r\n\tpublic #if cs inline #end static function ltrim(s:String):String {\r\n\t\t#if cs\r\n\t\treturn untyped s.TrimStart();\r\n\t\t#else\r\n\t\tvar l = s.length;\r\n\t\tvar r = 0;\r\n\t\twhile (r < l && isSpace(s, r)) {\r\n\t\t\tr++;\r\n\t\t}\r\n\t\tif (r > 0)\r\n\t\t\treturn s.substr(r, l - r);\r\n\t\telse\r\n\t\t\treturn s;\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tRemoves trailing space characters of `s`.\r\n\r\n\t\tThis function internally calls `isSpace()` to decide which characters to\r\n\t\tremove.\r\n\r\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\r\n\t\tresult is the empty String `\"\"`.\r\n\t**/\r\n\tpublic #if cs inline #end static function rtrim(s:String):String {\r\n\t\t#if cs\r\n\t\treturn untyped s.TrimEnd();\r\n\t\t#else\r\n\t\tvar l = s.length;\r\n\t\tvar r = 0;\r\n\t\twhile (r < l && isSpace(s, l - r - 1)) {\r\n\t\t\tr++;\r\n\t\t}\r\n\t\tif (r > 0) {\r\n\t\t\treturn s.substr(0, l - r);\r\n\t\t} else {\r\n\t\t\treturn s;\r\n\t\t}\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tRemoves leading and trailing space characters of `s`.\r\n\r\n\t\tThis is a convenience function for `ltrim(rtrim(s))`.\r\n\t**/\r\n\tpublic #if (cs || java) inline #end static function trim(s:String):String {\r\n\t\t#if cs\r\n\t\treturn untyped s.Trim();\r\n\t\t#elseif java\r\n\t\treturn (cast s : java.NativeString).trim();\r\n\t\t#else\r\n\t\treturn ltrim(rtrim(s));\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\r\n\r\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\r\n\t\t`s` is returned unchanged.\r\n\r\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\r\n\r\n\t\tOtherwise the length may exceed `l`.\r\n\r\n\t\tIf `c` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static function lpad(s:String, c:String, l:Int):String {\r\n\t\tif (c.length <= 0)\r\n\t\t\treturn s;\r\n\r\n\t\tvar buf = new StringBuf();\r\n\t\tl -= s.length;\r\n\t\twhile (buf.length < l) {\r\n\t\t\tbuf.add(c);\r\n\t\t}\r\n\t\tbuf.add(s);\r\n\t\treturn buf.toString();\r\n\t}\r\n\r\n\t/**\r\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\r\n\r\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\r\n\t\t`s` is returned unchanged.\r\n\r\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\r\n\r\n\t\tOtherwise the length may exceed `l`.\r\n\r\n\t\tIf `c` is null, the result is unspecified.\r\n\t**/\r\n\tpublic static function rpad(s:String, c:String, l:Int):String {\r\n\t\tif (c.length <= 0)\r\n\t\t\treturn s;\r\n\r\n\t\tvar buf = new StringBuf();\r\n\t\tbuf.add(s);\r\n\t\twhile (buf.length < l) {\r\n\t\t\tbuf.add(c);\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}\r\n\r\n\t/**\r\n\t\tReplace all occurrences of the String `sub` in the String `s` by the\r\n\t\tString `by`.\r\n\r\n\t\tIf `sub` is the empty String `\"\"`, `by` is inserted after each character\r\n\t\tof `s` except the last one. If `by` is also the empty String `\"\"`, `s`\r\n\t\tremains unchanged.\r\n\r\n\t\tIf `sub` or `by` are null, the result is unspecified.\r\n\t**/\r\n\tpublic static function replace(s:String, sub:String, by:String):String {\r\n\t\t#if java\r\n\t\tif (sub.length == 0)\r\n\t\t\treturn s.split(sub).join(by);\r\n\t\telse\r\n\t\t\treturn (cast s : java.NativeString).replace(sub, by);\r\n\t\t#elseif cs\r\n\t\tif (sub.length == 0)\r\n\t\t\treturn s.split(sub).join(by);\r\n\t\telse\r\n\t\t\treturn untyped s.Replace(sub, by);\r\n\t\t#else\r\n\t\treturn s.split(sub).join(by);\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tEncodes `n` into a hexadecimal representation.\r\n\r\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\r\n\t\tits `length` equals `digits`.\r\n\t**/\r\n\tpublic static function hex(n:Int, ?digits:Int) {\r\n\t\t#if flash\r\n\t\tvar n:UInt = n;\r\n\t\tvar s:String = untyped n.toString(16);\r\n\t\ts = s.toUpperCase();\r\n\t\t#else\r\n\t\tvar s = \"\";\r\n\t\tvar hexChars = \"0123456789ABCDEF\";\r\n\t\tdo {\r\n\t\t\ts = hexChars.charAt(n & 15) + s;\r\n\t\t\tn >>>= 4;\r\n\t\t} while (n > 0);\r\n\t\t#end\r\n\t\t#if python\r\n\t\tif (digits != null && s.length < digits) {\r\n\t\t\tvar diff = digits - s.length;\r\n\t\t\tfor (_ in 0...diff) {\r\n\t\t\t\ts = \"0\" + s;\r\n\t\t\t}\r\n\t\t}\r\n\t\t#else\r\n\t\tif (digits != null)\r\n\t\t\twhile (s.length < digits)\r\n\t\t\t\ts = \"0\" + s;\r\n\t\t#end\r\n\t\treturn s;\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns the character code at position `index` of String `s`, or an\r\n\t\tend-of-file indicator at if `position` equals `s.length`.\r\n\r\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\r\n\t\tthe result is unspecified if `index` is negative or greater than\r\n\t\t`s.length`.\r\n\r\n\t\tEnd of file status can be checked by calling `StringTools.isEof()` with\r\n\t\tthe returned value as argument.\r\n\r\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\r\n\t\tcharacter.\r\n\t**/\r\n\tpublic static #if !eval inline #end function fastCodeAt(s:String, index:Int):Int {\r\n\t\t#if neko\r\n\t\treturn untyped __dollar__sget(s.__s, index);\r\n\t\t#elseif cpp\r\n\t\treturn untyped s.cca(index);\r\n\t\t#elseif flash\r\n\t\treturn untyped s.cca(index);\r\n\t\t#elseif java\r\n\t\treturn (index < s.length) ? cast(_charAt(s, index), Int) : -1;\r\n\t\t#elseif cs\r\n\t\treturn (cast(index, UInt) < s.length) ? cast(s[index], Int) : -1;\r\n\t\t#elseif js\r\n\t\treturn (cast s).charCodeAt(index);\r\n\t\t#elseif python\r\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\r\n\t\t#elseif hl\r\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\r\n\t\t#elseif lua\r\n\t\t#if lua_vanilla\r\n\t\treturn lua.NativeStringTools.byte(s, index + 1);\r\n\t\t#else\r\n\t\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\r\n\t\t#end\r\n\t\t#else\r\n\t\treturn untyped s.cca(index);\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns the character code at position `index` of String `s`, or an\r\n\t\tend-of-file indicator at if `position` equals `s.length`.\r\n\r\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\r\n\t\tthe result is unspecified if `index` is negative or greater than\r\n\t\t`s.length`.\r\n\r\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\r\n\t\tcharacter.\r\n\t**/\r\n\tpublic static #if !eval inline #end function unsafeCodeAt(s:String, index:Int):Int {\r\n\t\t#if neko\r\n\t\treturn untyped __dollar__sget(s.__s, index);\r\n\t\t#elseif cpp\r\n\t\treturn untyped s.cca(index);\r\n\t\t#elseif flash\r\n\t\treturn untyped s.cca(index);\r\n\t\t#elseif java\r\n\t\treturn cast(_charAt(s, index), Int);\r\n\t\t#elseif cs\r\n\t\treturn cast(s[index], Int);\r\n\t\t#elseif js\r\n\t\treturn (cast s).charCodeAt(index);\r\n\t\t#elseif python\r\n\t\treturn python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\r\n\t\t#elseif hl\r\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\r\n\t\t#elseif lua\r\n\t\t#if lua_vanilla\r\n\t\treturn lua.NativeStringTools.byte(s, index + 1);\r\n\t\t#else\r\n\t\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\r\n\t\t#end\r\n\t\t#else\r\n\t\treturn untyped s.cca(index);\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns an iterator of the char codes.\r\n\r\n\t\tNote that char codes may differ across platforms because of different\r\n\t\tinternal encoding of strings in different runtimes.\r\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.\r\n\t**/\r\n\tpublic static inline function iterator(s:String):StringIterator {\r\n\t\treturn new StringIterator(s);\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns an iterator of the char indexes and codes.\r\n\r\n\t\tNote that char codes may differ across platforms because of different\r\n\t\tinternal encoding of strings in different of runtimes.\r\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.\r\n\t**/\r\n\tpublic static inline function keyValueIterator(s:String):StringKeyValueIterator {\r\n\t\treturn new StringKeyValueIterator(s);\r\n\t}\r\n\r\n\t/**\r\n\t\tTells if `c` represents the end-of-file (EOF) character.\r\n\t**/\r\n\t@:noUsing public static inline function isEof(c:Int):Bool {\r\n\t\t#if (flash || cpp || hl)\r\n\t\treturn c == 0;\r\n\t\t#elseif js\r\n\t\treturn c != c; // fast NaN\r\n\t\t#elseif (neko || lua || eval)\r\n\t\treturn c == null;\r\n\t\t#elseif (cs || java || python)\r\n\t\treturn c == -1;\r\n\t\t#else\r\n\t\treturn false;\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns a String that can be used as a single command line argument\r\n\t\ton Unix.\r\n\t\tThe input will be quoted, or escaped if necessary.\r\n\t**/\r\n\t@:noCompletion\r\n\t@:deprecated('StringTools.quoteUnixArg() is deprecated. Use haxe.SysTools.quoteUnixArg() instead.')\r\n\tpublic static function quoteUnixArg(argument:String):String {\r\n\t\treturn inline haxe.SysTools.quoteUnixArg(argument);\r\n\t}\r\n\r\n\t/**\r\n\t\tCharacter codes of the characters that will be escaped by `quoteWinArg(_, true)`.\r\n\t**/\r\n\t@:noCompletion\r\n\t@:deprecated('StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead.')\r\n\tpublic static var winMetaCharacters:Array<Int> = cast haxe.SysTools.winMetaCharacters;\r\n\r\n\t/**\r\n\t\tReturns a String that can be used as a single command line argument\r\n\t\ton Windows.\r\n\t\tThe input will be quoted, or escaped if necessary, such that the output\r\n\t\twill be parsed as a single argument using the rule specified in\r\n\t\thttp://msdn.microsoft.com/en-us/library/ms880421\r\n\r\n\t\tExamples:\r\n\t\t```haxe\r\n\t\tquoteWinArg(\"abc\") == \"abc\";\r\n\t\tquoteWinArg(\"ab c\") == '\"ab c\"';\r\n\t\t```\r\n\t**/\r\n\t@:noCompletion\r\n\t@:deprecated('StringTools.quoteWinArg() is deprecated. Use haxe.SysTools.quoteWinArg() instead.')\r\n\tpublic static function quoteWinArg(argument:String, escapeMetaCharacters:Bool):String {\r\n\t\treturn inline haxe.SysTools.quoteWinArg(argument, escapeMetaCharacters);\r\n\t}\r\n\r\n\t#if java\r\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16\r\n\t\treturn (cast str : java.NativeString).charAt(idx);\r\n\t#end\r\n\r\n\t#if neko\r\n\tprivate static var _urlEncode = neko.Lib.load(\"std\", \"url_encode\", 1);\r\n\tprivate static var _urlDecode = neko.Lib.load(\"std\", \"url_decode\", 1);\r\n\t#end\r\n\r\n\t#if utf16\r\n\tstatic inline var MIN_SURROGATE_CODE_POINT = 65536;\r\n\r\n\tstatic inline function utf16CodePointAt(s:String, index:Int):Int {\r\n\t\tvar c = StringTools.fastCodeAt(s, index);\r\n\t\tif (c >= 0xD800 && c <= 0xDBFF) {\r\n\t\t\tc = ((c - 0xD7C0) << 10) | (StringTools.fastCodeAt(s, index + 1) & 0x3FF);\r\n\t\t}\r\n\t\treturn c;\r\n\t}\r\n\t#end\r\n}\r\n","import discord_js.Message;\r\nimport sys.io.File;\r\nimport haxe.Json;\r\nimport haxe.PosInfos;\r\n\r\nfunction loadFile(filename:String, ?pos:PosInfos):Dynamic {\r\n\tvar data = null;\r\n\ttry {\r\n\t\tdata = Json.parse(File.getContent('./commands/$filename.json'));\r\n\t} catch (e) {\r\n\t\ttrace(e);\r\n\t\ttrace('Failed to load file or parse json', pos);\r\n\t}\r\n\treturn data;\r\n}\r\n\r\nfunction hasRole(role:String, message:Message) {\r\n\tvar guild = message.guild.roles.cache.get(role);\r\n\treturn (message.guild.available && !guild!.members!.has(message.author.id));\r\n}","package bits;\n\nimport haxe.io.BytesData;\n/**\n * A sequence of bits of any size.\n */\nabstract Bits(BitsData) from BitsData to BitsData {\n\t/**\n\t * Create a `bits.Bits` instance using values of `positions` as positions of bits, which should be set to 1.\n\t * E.g. `[0, 2, 7]` will produce `bits.Bits` instance of `10000101`.\n\t * If there is a negative value in `positions` the result is unspecified.\n\t */\n\t@:from\n\tstatic public function fromPositions(positions:Array<Int>):Bits {\n\t\tvar bits = new Bits();\n\t\tfor(pos in positions) {\n\t\t\t#if haxe4 inline #end bits.set(pos);\n\t\t}\n\t\treturn bits;\n\t}\n\n\t/**\n\t * Create a new instance.\n\t *\n\t * By default the new instance allocates a memory for 32 (on most platforms) bits.\n\t * And then grows as necessary on setting bits at positions greater than 31.\n\t *\n\t * @param capacity makes `bits.Bits` to pre-allocate the amount of memory required to store `capacity` bits.\n\t */\n\tpublic inline function new(capacity:Int = 0) {\n\t\tthis = new BitsData();\n\t\tif(capacity > 0) {\n\t\t\tthis.resize(Math.ceil(capacity / BitsData.CELL_SIZE));\n\t\t}\n\t}\n\n\t/**\n\t * Set the bit at position `pos` (zero-based) in a binary representation of `bits.BitFlags` to 1.\n\t * It's like `bits = bits | (1 << pos)`\n\t * E.g. if `pos` is 2 the third bit is set to 1 (`0000100`).\n\t * If `pos` is negative the result is unspecified.\n\t */\n\tpublic function set(pos:Int) {\n\t\tif(pos < BitsData.CELL_SIZE) {\n\t\t\tthis[0] |= (1 << pos);\n\t\t} else {\n\t\t\tvar cell = Std.int(pos / BitsData.CELL_SIZE);\n\t\t\tif(this.length <= cell) {\n\t\t\t\tthis.resize(cell + 1);\n\t\t\t}\n\t\t\tvar bit = pos - cell * BitsData.CELL_SIZE;\n\t\t\tthis[cell] |= (1 << bit);\n\t\t}\n\t}\n\n\t/**\n\t * Set the bit at position `pos` (zero-based) in a binary representation of `bits.BitFlags` to 0.\n\t * If `pos` is negative the result is unspecified.\n\t */\n\tpublic function unset(pos:Int) {\n\t\tif(pos < BitsData.CELL_SIZE) {\n\t\t\tthis[0] &= ~(1 << pos);\n\t\t} else {\n\t\t\tvar cell = Std.int(pos / BitsData.CELL_SIZE);\n\t\t\tif(this.length <= cell) {\n\t\t\t\tthis.resize(cell + 1);\n\t\t\t}\n\t\t\tvar bit = pos - cell * BitsData.CELL_SIZE;\n\t\t\tthis[cell] &= ~(1 << bit);\n\t\t}\n\t}\n\n\t/**\n\t * Add all ones of `bits` to this instance.\n\t * It's like `this = this | bits`.\n\t */\n\tpublic function add(bits:Bits) {\n\t\tvar data = (bits:BitsData);\n\t\tif(this.length < data.length) {\n\t\t\tthis.resize(data.length);\n\t\t}\n\t\tfor(cell in 0...data.length) {\n\t\t\tthis[cell] |= data[cell];\n\t\t}\n\t}\n\n\t/**\n\t * Remove all ones of `bits` from this instance.\n\t * It's like `this = this & ~bits`.\n\t */\n\tpublic function remove(bits:Bits) {\n\t\tvar data = (bits:BitsData);\n\t\tfor(cell in 0...data.length) {\n\t\t\tif(cell >= this.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis[cell] &= ~data[cell];\n\t\t}\n\t}\n\n\t/**\n\t * Check if a bit at position `pos` is set to 1.\n\t * If `pos` is negative the result is unspecified.\n\t */\n\tpublic function isSet(pos:Int):Bool {\n\t\treturn if(pos < BitsData.CELL_SIZE) {\n\t\t\t0 != this[0] & (1 << pos);\n\t\t} else {\n\t\t\tvar cell = Std.int(pos / BitsData.CELL_SIZE);\n\t\t\tvar bit = pos - cell * BitsData.CELL_SIZE;\n\t\t\tcell < this.length && 0 != this[cell] & (1 << bit);\n\t\t}\n\t}\n\n\t/**\n\t * Check if this instance has all the corresponding bits of `bits` set.\n\t * It's like `this & bits != 0`.\n\t * E.g. returns `true` if `this` is `10010010` and `bits` is `10000010`.\n\t */\n\tpublic function areSet(bits:Bits):Bool {\n\t\tvar data = (bits:BitsData);\n\t\tvar has = true;\n\t\tfor(cell in 0...data.length) {\n\t\t\tif(cell < this.length) {\n\t\t\t\thas = data[cell] == this[cell] & data[cell];\n\t\t\t} else {\n\t\t\t\thas = 0 == data[cell];\n\t\t\t}\n\t\t\tif(!has) break;\n\t\t}\n\t\treturn has;\n\t}\n\n\t/**\n\t * Invoke `callback` for each non-zero bit.\n\t * Callback will receive a position (zero-based) of each non-zero bit.\n\t */\n\tpublic inline function forEach(callback:Int->Void) {\n\t\tfor(cell in 0...this.length) {\n\t\t\tvar cellValue = this[cell];\n\t\t\tif(cellValue != 0) {\n\t\t\t\tfor(i in 0...BitsData.CELL_SIZE) {\n\t\t\t\t\tif(0 != cellValue & (1 << i)) {\n\t\t\t\t\t\tcallback(cell * BitsData.CELL_SIZE + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create a copy of this instance\n\t */\n\tpublic inline function copy():Bits {\n\t\treturn this.copy();\n\t}\n\n\t/**\n\t * Get string representation of this instance (without leading zeros).\n\t * E.g. `100010010`.\n\t */\n\tpublic function toString():String {\n\t\tvar result = '';\n\t\tfor(cell in 0...this.length) {\n\t\t\tvar cellValue = this[cell];\n\t\t\tfor(i in 0...BitsData.CELL_SIZE) {\n\t\t\t\tresult = (0 != cellValue & (1 << i) ? '1' : '0') + result;\n\t\t\t}\n\t\t}\n\t\treturn result.substr(result.indexOf('1'));\n\t}\n\n\t/**\n\t * Check if all bits are zeros\n\t */\n\tpublic function isEmpty():Bool {\n\t\tvar empty = true;\n\t\tfor(cellValue in this) {\n\t\t\tif(cellValue != 0) {\n\t\t\t\tempty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn empty;\n\t}\n\n\t/**\n\t * Count the amount of non-zero bits.\n\t */\n\tpublic function count():Int {\n\t\treturn this.countOnes();\n\t}\n\n\t/**\n\t * Set all bits to 0\n\t */\n\tpublic function clear() {\n\t\tfor(cell in 0...this.length) {\n\t\t\tthis[cell] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Merge this instance with `bits`.\n\t * E.g. merging `10010` and `10001` produces `10011`.\n\t * Creates a new `bits.Bits` instance.\n\t */\n\t@:op(A | B)\n\tpublic function merge(bits:Bits):Bits {\n\t\tinline function mergeData(a:BitsData, b:BitsData):BitsData {\n\t\t\tvar result = a.copy();\n\t\t\tfor(cell in 0...b.length) {\n\t\t\t\tresult[cell] |= b[cell];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif(this.length < (bits:BitsData).length) {\n\t\t\treturn mergeData(bits, this);\n\t\t} else {\n\t\t\treturn mergeData(this, bits);\n\t\t}\n\t}\n\n\t/**\n\t * Returns an intersection of this instance with `bits`.\n\t * E.g. intersecting `10010` and `01010` produces `00010`.\n\t * Creates a new `bits.Bits` instance.\n\t */\n\t@:op(A & B)\n\tpublic function intersect(bits:Bits):Bits {\n\t\tinline function intersectData(a:BitsData, b:BitsData):BitsData {\n\t\t\tvar result = a.copy();\n\t\t\tfor(cell in 0...a.length) {\n\t\t\t\tresult[cell] &= b[cell];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif(this.length < (bits:BitsData).length) {\n\t\t\treturn intersectData(this, bits);\n\t\t} else {\n\t\t\treturn intersectData(bits, this);\n\t\t}\n\t}\n\n\t/**\n\t * Iterator over the positions of non-zero bits\n\t */\n\tpublic inline function iterator():BitsIterator {\n\t\treturn new BitsIterator(this);\n\t}\n}\n\nclass BitsIterator {\n\tvar data:BitsData;\n\tvar cell:Int = 0;\n\tvar i:Int = 0;\n\n\tpublic inline function new(data:BitsData) {\n\t\tthis.data = data;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\tvar has = false;\n\n\t\twhile(cell < data.length) {\n\t\t\tvar cellValue = data[cell];\n\n\t\t\tif(cellValue != 0) {\n\t\t\t\twhile(i < BitsData.CELL_SIZE) {\n\t\t\t\t\tif(cellValue & (1 << i) != 0) {\n\t\t\t\t\t\thas = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t\tif(has) break;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\t++cell;\n\t\t}\n\n\t\treturn has;\n\t}\n\n\tpublic inline function next():Int {\n\t\t++i;\n\t\treturn cell * BitsData.CELL_SIZE + i - 1;\n\t}\n}\n\n//TODO change to the most effective data structure for each target platform\n@:noCompletion\nabstract BitsData(Array<Int>) {\n\tstatic public inline var CELL_SIZE = 32;\n\n\tpublic var length(get,never):Int;\n\n\tpublic inline function new() this = [0];\n\n\tpublic inline function resize(newLength:Int) {\n\t\t#if (!haxe4 || !static)\n\t\t\tfor(i in this.length...newLength) {\n\t\t\t\tthis[i] = 0;\n\t\t\t}\n\t\t#else\n\t\t\tthis.resize(newLength);\n\t\t#end\n\t}\n\n\tpublic inline function copy():BitsData {\n\t\treturn cast this.copy();\n\t}\n\n\t/**\n\t * Count 1-bits\n\t */\n\tpublic inline function countOnes():Int {\n\t\tvar result = 0;\n\t\t#if (neko || js || java || cs || cpp || flash)\n\t\t\tfor(v in this) {\n\t\t\t\tif(v != 0) {\n\t\t\t\t\tv = v - ((v >>> 1) & 0x55555555);\n\t\t\t\t\tv = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n\t\t\t\t\tresult += (((v + (v >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t#else\n\t\t\tfor(cellValue in this) {\n\t\t\t\tif(cellValue != 0) {\n\t\t\t\t\tfor(i in 0...CELL_SIZE) {\n\t\t\t\t\t\tif(cellValue & (1 << i) != 0) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t#end\n\t\treturn result;\n\t}\n\n\t@:op([])\n\tinline function get(index:Int):Int {\n\t\treturn this[index];\n\t}\n\n\t@:op([])\n\tinline function set(index:Int, value:Int):Int {\n\t\treturn this[index] = value;\n\t}\n\n\tinline function get_length() return this.length;\n}","package ecs;\r\n\r\nimport haxe.ds.Vector;\r\n\r\n#if ecs.static_loading @:generic #end class Components<T>\r\n{\r\n    final components : Vector<T>;\r\n\r\n    public function new(_size)\r\n    {\r\n        components = new Vector(_size);\r\n    }\r\n\r\n    public function set(_entity : Entity, _component : T)\r\n    {\r\n        components[_entity.id()] = _component;\r\n    }\r\n\r\n    public function get(_entity : Entity) : T\r\n    {\r\n        return components[_entity.id()];\r\n    }\r\n}","package ecs;\r\n\r\nabstract Entity(Int)\r\n{\r\n    public static final none = new Entity(-1);\r\n\r\n    public function new(_id)\r\n    {\r\n        this = _id;\r\n    }\r\n\r\n    public function id()\r\n    {\r\n        return this;\r\n    }\r\n}","package ecs;\r\n\r\nimport ecs.ds.Signal;\r\nimport ecs.ds.SparseSet;\r\nimport bits.Bits;\r\n\r\nclass Family\r\n{\r\n    public final id : Int;\r\n\r\n    public final componentsMask : Bits;\r\n\r\n    public final resourcesMask : Bits;\r\n\r\n    public final onEntityAdded : Signal<Entity>;\r\n\r\n    public final onEntityRemoved : Signal<Entity>;\r\n\r\n    final entities : SparseSet;\r\n\r\n    var active : Bool;\r\n\r\n    public function new(_id, _cmpMask, _resMask, _size)\r\n    {\r\n        id              = _id;\r\n        componentsMask  = _cmpMask;\r\n        resourcesMask   = _resMask;\r\n        onEntityAdded   = new Signal();\r\n        onEntityRemoved = new Signal();\r\n        entities        = new SparseSet(_size);\r\n        active          = if (resourcesMask.isEmpty()) true else false;\r\n    }\r\n\r\n    public function add(_entity)\r\n    {\r\n        if (!entities.has(_entity))\r\n        {\r\n            entities.insert(_entity);\r\n\r\n            if (isActive())\r\n            {\r\n                onEntityAdded.notify(_entity);\r\n            }\r\n        }\r\n    }\r\n\r\n    public function remove(_entity)\r\n    {\r\n        if (entities.has(_entity))\r\n        {\r\n            entities.remove(_entity);\r\n            \r\n            if (isActive())\r\n            {\r\n                onEntityRemoved.notify(_entity);\r\n            }\r\n        }\r\n    }\r\n\r\n    public function has(_entity)\r\n    {\r\n        return entities.has(_entity);\r\n    }\r\n\r\n    public function activate()\r\n    {\r\n        if (!active)\r\n        {\r\n            active = true;\r\n\r\n            for (i in 0...entities.size())\r\n            {\r\n                onEntityAdded.notify(entities.getDense(i));\r\n            }\r\n        }\r\n    }\r\n\r\n    public function deactivate()\r\n    {\r\n        if (active)\r\n        {\r\n            for (i in 0...entities.size())\r\n            {\r\n                onEntityRemoved.notify(entities.getDense(i));\r\n            }\r\n\r\n            active = false;\r\n        }\r\n    }\r\n\r\n    public function isActive()\r\n    {\r\n        return active;\r\n    }\r\n\r\n    public function iterator()\r\n    {\r\n        return new FamilyIterator(entities, isActive());\r\n    }\r\n}\r\n\r\nprivate class FamilyIterator\r\n{\r\n    final set : SparseSet;\r\n\r\n    final active : Bool;\r\n\r\n    var idx : Int;\r\n\r\n    public inline function new(_set, _active)\r\n    {\r\n        set    = _set;\r\n        active = _active;\r\n        idx    = 0;\r\n    }\r\n\r\n    public inline function hasNext()\r\n    {\r\n        return active && idx < set.size();\r\n    }\r\n\r\n    public inline function next()\r\n    {\r\n        return set.getDense(idx++);\r\n    }\r\n}","package ecs;\r\n\r\n@:autoBuild(ecs.macros.SystemMacros.familyConstruction()) class System\r\n{\r\n\tfinal universe : Universe;\r\n\r\n\tpublic function new(_universe)\r\n\t{\r\n\t\tuniverse = _universe;\r\n\t}\r\n\r\n\tpublic function onAdded()\r\n\t{\r\n\t\t//\r\n\t}\r\n\r\n\tpublic function update(_dt : Float)\r\n\t{\r\n\t\t//\r\n\t}\r\n\r\n\tpublic function onRemoved()\r\n\t{\r\n\t\t//\r\n\t}\r\n}","package ecs;\r\n\r\nimport ecs.core.ResourceManager;\r\nimport ecs.core.EntityManager;\r\nimport ecs.core.FamilyManager;\r\nimport ecs.core.SystemManager;\r\nimport ecs.core.ComponentManager;\r\n\r\nclass Universe\r\n{\r\n    public final entities : EntityManager;\r\n    public final components : ComponentManager;\r\n    public final resources : ResourceManager;\r\n    public final families : FamilyManager;\r\n    public final systems : SystemManager;\r\n\r\n    public function new(_maxEntities)\r\n    {\r\n        entities   = new EntityManager(_maxEntities);\r\n        components = new ComponentManager(entities);\r\n        resources  = new ResourceManager();\r\n        families   = new FamilyManager(components, resources, _maxEntities);\r\n        systems    = new SystemManager();\r\n    }\r\n\r\n    public function update(_dt : Float)\r\n    {\r\n        systems.update(_dt);\r\n    }\r\n}","package ecs.core;\r\n\r\nimport haxe.ds.Vector;\r\nimport bits.Bits;\r\n\r\nclass ComponentManager\r\n{\r\n    final entities : EntityManager;\r\n\r\n    /**\r\n     * All components stored in this system.\r\n     * Index into the vector with the components ID to get all components of that type.\r\n     */\r\n    final components : Vector<Any>;\r\n\r\n    /**\r\n     * Bit flags for each entity in the universe.\r\n     * If a bit is set then it has the component of that index / id.\r\n     */\r\n    public final flags : Vector<Bits>;\r\n\r\n    public function new(_entities)\r\n    {\r\n        entities = _entities;\r\n        flags    = new Vector(_entities.capacity());\r\n\r\n#if ecs.static_loading\r\n        components = ecs.macros.ComponentMacros.createComponentVector();\r\n\r\n        ecs.macros.ComponentMacros.setupComponents(_entities.capacity());\r\n#else\r\n        final meta           = haxe.rtti.Meta.getType(ComponentManager);\r\n        final componentCount = meta.componentCount[0];\r\n        final componentIDs   = meta.components;\r\n        \r\n        components = new Vector(componentCount);\r\n\r\n        for (id in componentIDs)\r\n        {\r\n            components.set(id, new ecs.Components<Any>(_entities.capacity()));\r\n        }\r\n#end\r\n\r\n        for (i in 0...flags.length)\r\n        {\r\n            flags[i] = new Bits();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the components table for the specified component ID.\r\n     * @param _compID Unique component ID.\r\n     */\r\n    public function getTable<T>(_compID : Int) : Any\r\n    {\r\n        return components[_compID];\r\n    }\r\n\r\n#if ecs.static_loading\r\n    @:generic public function set<T>(_entity : Entity, _id : Int, _component : T)\r\n    {\r\n        (components[_id] : Components<T>).set(_entity, _component);\r\n\r\n        flags[_entity.id()].set(_id);\r\n    }\r\n#else\r\n    public function set(_entity : Entity, _id : Int, _component : Any)\r\n    {\r\n        (components[_id] : Components<Any>).set(_entity, _component);\r\n\r\n        flags[_entity.id()].set(_id);\r\n    }\r\n#end\r\n\r\n    public function remove(_entity : Entity, _id : Int)\r\n    {\r\n        flags[_entity.id()].unset(_id);\r\n    }\r\n\r\n    public function clear(_entity : Entity)\r\n    {\r\n        flags[_entity.id()].clear();\r\n    }\r\n}","package ecs.macros;\r\n\r\nimport haxe.macro.Expr;\r\nimport ecs.macros.ComponentCache;\r\n\r\nusing Safety;\r\nusing haxe.macro.Tools;\r\n\r\n/**\r\n * Returns an expression creating a `haxe.ds.Vector` with capacity to store all the seen components.\r\n */\r\nmacro function createComponentVector()\r\n{\r\n    return macro new haxe.ds.Vector($v{ getComponentCount() });\r\n}\r\n\r\n/**\r\n * Called in the constructor of `ecs.core.ComponentManager` and instantiates a components table for every component used to the `components` vector.\r\n * @param _size Expression which contains the maximum number of entities.\r\n */\r\nmacro function setupComponents(_size : Expr)\r\n{\r\n    final creation = [];\r\n\r\n    for (_ => value in getComponentMap())\r\n    {\r\n        final ct = value.type.toComplexType();\r\n\r\n        creation.push(macro components.set($v{ value.id }, new ecs.Components<$ct>($e{ _size })));\r\n    }\r\n\r\n    return macro $b{ creation };\r\n}","package ecs.core;\r\n\r\nimport haxe.ds.Vector;\r\n\r\nclass EntityManager\r\n{\r\n    final storage : Vector<Entity>;\r\n\r\n    var nextID : Int;\r\n\r\n    public function new(_max)\r\n    {\r\n        storage = new Vector(_max);\r\n        nextID  = 0;\r\n    }\r\n\r\n    public function create()\r\n    {\r\n        final idx = nextID++;\r\n        final e   = new Entity(idx);\r\n\r\n        storage[idx] = e;\r\n\r\n        return e;\r\n    }\r\n\r\n    public function get(_id : Int)\r\n    {\r\n        return storage[_id];\r\n    }\r\n\r\n    public function capacity()\r\n    {\r\n        return storage.length;\r\n    }\r\n}","package ecs.core;\r\n\r\nimport bits.Bits;\r\nimport haxe.ds.Vector;\r\nimport ecs.core.ComponentManager;\r\n\r\nclass FamilyManager\r\n{\r\n    public final number : Int;\r\n\r\n    final components : ComponentManager;\r\n\r\n    final resources : ResourceManager;\r\n\r\n    final families : Vector<Family>;\r\n\r\n    public function new(_components, _resources, _size)\r\n    {\r\n#if ecs.static_loading\r\n        families = ecs.macros.FamilyMacros.createFamilyVector();\r\n        ecs.macros.FamilyMacros.setupFamilies(_size);\r\n#else\r\n        final meta           = haxe.rtti.Meta.getType(FamilyManager);\r\n        final componentCount = meta.componentCount[0];\r\n        final resourceCount  = meta.resourceCount[0];\r\n        final allFamilies    = meta.families;\r\n        \r\n        families = new Vector(allFamilies.length);\r\n        for (idx => family in allFamilies)\r\n        {\r\n            final cmpBits = new Bits();\r\n            for (id in (family.components : Array<Int>))\r\n            {\r\n                cmpBits.set(id);\r\n            }\r\n\r\n            final resBits = new Bits();\r\n            for (id in (family.resources : Array<Int>))\r\n            {\r\n                resBits.set(id);\r\n            }\r\n\r\n            families.set(idx, new Family(idx, cmpBits, resBits, _size));\r\n        }\r\n#end\r\n\r\n        components = _components;\r\n        resources  = _resources;\r\n        number     = families.length;\r\n    }\r\n\r\n    public function get(_index : Int)\r\n    {\r\n        return families[_index];\r\n    }\r\n\r\n    public function tryActivate(_id : Int)\r\n    {\r\n        if (!families[_id].isActive() && resources.flags.areSet(families[_id].resourcesMask))\r\n        {\r\n            families[_id].activate();\r\n        }\r\n    }\r\n\r\n    public function tryDeactivate(_id : Int, resourceID : Int)\r\n    {\r\n        if (!resources.flags.isSet(resourceID))\r\n        {\r\n            return;\r\n        }\r\n        if (!families[_id].isActive())\r\n        {\r\n            return;\r\n        }\r\n        if (families[_id].resourcesMask.isSet(resourceID))\r\n        {\r\n            families[_id].deactivate();\r\n        }\r\n    }\r\n\r\n    public function whenEntityDestroyed(_entity : Entity)\r\n    {\r\n        final compFlags = components.flags[_entity.id()];\r\n\r\n        for (family in families)\r\n        {          \r\n            if (!compFlags.areSet(family.componentsMask))\r\n            {\r\n                family.remove(_entity);\r\n            }\r\n        }\r\n    }\r\n}","package ecs.macros;\r\n\r\nimport haxe.macro.Expr;\r\nimport ecs.macros.FamilyCache;\r\nimport ecs.macros.ResourceCache;\r\nimport ecs.macros.ComponentCache;\r\n\r\nusing haxe.macro.Tools;\r\n\r\n/**\r\n * Creates a vector large enough to store all unique families.\r\n */\r\nmacro function createFamilyVector()\r\n{\r\n    return macro new haxe.ds.Vector($v{ getFamilyCount() });\r\n}\r\n\r\n/**\r\n * Used by `ecs.core.FamiliesManager`, returns a code block which populates the `faimilies` vectors.\r\n * Adds an `ecs.Family` instance for each family, generating a bit mask for the components and resources requested by it.\r\n * @param _size Expression which contains the maximum number of entities.\r\n */\r\nmacro function setupFamilies(_size : Expr)\r\n{\r\n    final creation = [];\r\n\r\n    for (idx => family in getFamilies())\r\n    {\r\n        // Create a bit flag set for all components in this family.\r\n        creation.push(macro final cmpBits = new bits.Bits($v{ getComponentCount() }));\r\n\r\n        for (field in family.components)\r\n        {\r\n            creation.push(macro cmpBits.set($v{ field.uID }));\r\n        }\r\n\r\n        // Create a bit flag set for all resources in this family.\r\n        creation.push(macro final resBits = new bits.Bits($v{ getResourceCount() }));\r\n\r\n        for (field in family.resources)\r\n        {\r\n            creation.push(macro resBits.set($v{ field.uID }));\r\n        }\r\n        \r\n        creation.push(macro families.set($v{ idx }, new ecs.Family($v{ idx }, cmpBits, resBits, $e{ _size })));\r\n    }\r\n\r\n    return macro $b{ creation }\r\n}","package ecs.core;\r\n\r\nimport haxe.ds.Vector;\r\nimport bits.Bits;\r\n\r\nclass ResourceManager\r\n{\r\n    /**\r\n     * Bits which indicate which resources are currently stored in the system.\r\n     */\r\n    public final flags : Bits;\r\n\r\n    /**\r\n     * Vector for storing all active resources.\r\n     */\r\n    final resources : Vector<Any>;\r\n\r\n    public function new()\r\n    {\r\n#if ecs.static_loading\r\n        flags     = ecs.macros.ResourceMacros.createResourceBits();\r\n        resources = ecs.macros.ResourceMacros.createResourceVector();\r\n#else\r\n        final resourceCount = haxe.rtti.Meta.getType(ResourceManager).resourceCount[0];\r\n        flags     = new Bits(resourceCount);\r\n        resources = new Vector(resourceCount);\r\n#end\r\n    }\r\n\r\n    /**\r\n     * Gets the resource with the provided ID.\r\n     * If the resource is not in the system null is returned.\r\n     * @param _id Resource ID.\r\n     */\r\n    public function get(_id : Int)\r\n    {\r\n        return resources[_id];\r\n    }\r\n\r\n    /**\r\n     * Add a resource into the world.\r\n     * @param _id Resource ID.\r\n     * @param _resource Resource object.\r\n     */\r\n    public function insert(_id : Int, _resource : Any)\r\n    {\r\n        resources[_id] = _resource;\r\n\r\n        flags.set(_id);\r\n    }\r\n\r\n    /**\r\n     * Remove a resource from the world.\r\n     * @param _id Resource ID.\r\n     */\r\n    public function remove(_id : Int)\r\n    {\r\n        flags.unset(_id);\r\n\r\n        resources[_id] = null;\r\n    }\r\n}","package ecs.macros;\r\n\r\nimport ecs.macros.ResourceCache;\r\n\r\nmacro function createResourceVector()\r\n{\r\n    return macro new haxe.ds.Vector($v{ getResourceCount() });\r\n}\r\n\r\nmacro function createResourceBits()\r\n{\r\n    return macro new bits.Bits($v{ getResourceCount() });\r\n}","package ecs.core;\r\n\r\nclass SystemManager\r\n{\r\n    final active : Array<System>;\r\n\r\n    public function new()\r\n    {\r\n        active = [];\r\n    }\r\n\r\n    public function add(_system : System)\r\n    {\r\n        active.push(_system);\r\n\r\n        _system.onAdded();\r\n    }\r\n\r\n    public function remove(_system : System)\r\n    {\r\n        _system.onRemoved();\r\n\r\n        active.remove(_system);\r\n    }\r\n\r\n    public function update(_dt : Float)\r\n    {\r\n        for (system in active)\r\n        {\r\n            system.update(_dt);\r\n        }\r\n    }\r\n}","package ecs.ds;\r\n\r\nusing Lambda;\r\n\r\nclass Set<T>\r\n{\r\n    final data : Array<T>;\r\n\r\n    public function new()\r\n    {\r\n        data = [];\r\n    }\r\n\r\n    public function add(_value : T)\r\n    {\r\n        if (!data.has(_value))\r\n        {\r\n            data.push(_value);\r\n        }\r\n    }\r\n\r\n    public function iterator() : Iterator<T>\r\n    {\r\n        return data.iterator();\r\n    }\r\n}","package ecs.ds;\r\n\r\n@:generic class Signal<T>\r\n{\r\n    final subscribers : Array<T->Void>;\r\n\r\n    public function new()\r\n    {\r\n        subscribers = [];\r\n    }\r\n\r\n    public function subscribe(_func : T->Void)\r\n    {\r\n        if (subscribers.indexOf(_func) == -1)\r\n        {\r\n            subscribers.push(_func);\r\n        }\r\n    }\r\n\r\n    public function unsubscribe(_func : T->Void)\r\n    {\r\n        subscribers.remove(_func);\r\n    }\r\n\r\n    public function notify(_data : T)\r\n    {\r\n        for (func in subscribers)\r\n        {\r\n            func(_data);\r\n        }\r\n    }\r\n}","package ecs.ds;\r\n\r\nimport haxe.ds.Vector;\r\n\r\n/**\r\n * Sparse set of entities contains both a dense and sparse vector for storage.\r\n * This allows O(1) insertion, removal, and searching of entities and allows them to be iterated over in a dense array.\r\n * Entities are not guarenteed to be in the order they were inserted.\r\n */\r\nclass SparseSet\r\n{\r\n    /**\r\n     * Sparse vector which contains indices into the dense vector.\r\n     * Index using an entity to find the corresponding dense vector position.\r\n     */\r\n    final sparse : Vector<Int>;\r\n\r\n    /**\r\n     * Packed array of all entity values\r\n     */\r\n    final dense : Vector<Entity>;\r\n\r\n    /**\r\n     * Number of entities currently stored in the dense vector.\r\n     */\r\n    var number : Int;\r\n\r\n    /**\r\n     * Create a new sparse set of entities.\r\n     * On creation all sparse values point to the first element of the dense array and all dense array values contain -1 (null entity).\r\n     * @param _size Maximum number of entities this set can contain.\r\n     */\r\n    public function new(_size)\r\n    {\r\n        sparse = new Vector(_size);\r\n        dense  = new Vector(_size);\r\n        number = 0;\r\n\r\n        for (i in 0...sparse.length)\r\n        {\r\n            sparse[i] = 0;\r\n        }\r\n        for (i in 0...dense.length)\r\n        {\r\n            dense[i] = Entity.none;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if the provided entity is stored in the sparse set.\r\n     * @param _entity Entity to check.\r\n     */\r\n    public function has(_entity : Entity)\r\n    {\r\n        return sparse[_entity.id()] < number && dense[sparse[_entity.id()]] == _entity;\r\n    }\r\n\r\n    /**\r\n     * Insert an entity into the sparse set.\r\n     * @param _entity Entity to insert.\r\n     */\r\n    public function insert(_entity : Entity)\r\n    {\r\n        dense[number] = _entity;\r\n        sparse[_entity.id()] = number;\r\n\r\n        number++;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the sparse set.\r\n     * Does not check if the entity is in the set before removing.\r\n     * @param _entity Entity to remove.\r\n     */\r\n    public function remove(_entity : Entity)\r\n    {\r\n        final temp = dense[number - 1];\r\n        dense[sparse[_entity.id()]] = temp;\r\n        sparse[temp.id()] = sparse[_entity.id()];\r\n\r\n        number--;\r\n    }\r\n\r\n    /**\r\n     * Get the entity at the provided dense vector location.\r\n     * @param _idx Dense vector index.\r\n     */\r\n    public function getDense(_idx : Int)\r\n    {\r\n        return dense[_idx];\r\n    }\r\n\r\n    /**\r\n     * Get the index into the dense vector that the provided entity is stored in.\r\n     * @param _entity Entity to get index of.\r\n     */\r\n    public function getSparse(_entity : Entity)\r\n    {\r\n        return sparse[_entity.id()];\r\n    }\r\n\r\n    /**\r\n     * Number of entity currently stored in the dense vector.\r\n     */\r\n    public function size()\r\n    {\r\n        return number;\r\n    }\r\n}","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage haxe.ds;\r\n\r\nimport js.lib.Object;\r\nimport haxe.Constraints.IMap;\r\nimport haxe.DynamicAccess;\r\n\r\n#if (js_es >= 5)\r\n@:coreApi class StringMap<T> implements IMap<String, T> {\r\n\tvar h:Dynamic;\r\n\r\n\tpublic inline function new() {\r\n\t\th = Object.create(null);\r\n\t}\r\n\r\n\tpublic inline function exists(key:String):Bool {\r\n\t\treturn Object.prototype.hasOwnProperty.call(h, key);\r\n\t}\r\n\r\n\tpublic inline function get(key:String):Null<T> {\r\n\t\treturn h[cast key];\r\n\t}\r\n\r\n\tpublic inline function set(key:String, value:T):Void {\r\n\t\th[cast key] = value;\r\n\t}\r\n\r\n\tpublic inline function remove(key:String):Bool {\r\n\t\treturn if (exists(key)) {\r\n\t\t\tjs.Syntax.delete(h, key); true;\r\n\t\t} else {\r\n\t\t\tfalse;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic inline function keys():Iterator<String> {\r\n\t\treturn new StringMapKeyIterator(h);\r\n\t}\r\n\r\n\tpublic inline function iterator():Iterator<T> {\r\n\t\treturn new StringMapValueIterator(h);\r\n\t}\r\n\r\n\tpublic inline function keyValueIterator():KeyValueIterator<String, T> {\r\n\t\treturn new StringMapKeyValueIterator(h);\r\n\t}\r\n\r\n\tpublic inline function copy():StringMap<T> {\r\n\t\treturn createCopy(h);\r\n\t}\r\n\r\n\tpublic inline function clear():Void {\r\n\t\th = Object.create(null);\r\n\t}\r\n\r\n\tpublic inline function toString():String {\r\n\t\treturn stringify(h);\r\n\t}\r\n\r\n\t// impl\r\n\tstatic function createCopy<T>(h:Dynamic):StringMap<T> {\r\n\t\tvar copy = new StringMap();\r\n\t\tjs.Syntax.code(\"for (var key in {0}) {1}[key] = {0}[key]\", h, copy.h);\r\n\t\treturn copy;\r\n\t}\r\n\r\n\t@:analyzer(no_optimize)\r\n\tstatic function stringify(h:Dynamic):String {\r\n\t\tvar s = \"{\", first = true;\r\n\t\tjs.Syntax.code(\"for (var key in {0}) {\", h);\r\n\t\tjs.Syntax.code(\"\\tif ({0}) {0} = false; else {1} += ',';\", first, s);\r\n\t\tjs.Syntax.code(\"\\t{0} += key + ' => ' + {1}({2}[key]);\", s, Std.string, h);\r\n\t\tjs.Syntax.code(\"}\");\r\n\t\treturn s + \"}\";\r\n\t}\r\n}\r\n\r\nprivate class StringMapKeyIterator {\r\n\tfinal h:Dynamic;\r\n\tfinal keys:Array<String>;\r\n\tfinal length:Int;\r\n\tvar current:Int;\r\n\r\n\tpublic inline function new(h:Dynamic) {\r\n\t\tthis.h = h;\r\n\t\tkeys = Object.keys(h);\r\n\t\tlength = keys.length;\r\n\t\tcurrent = 0;\r\n\t}\r\n\r\n\tpublic inline function hasNext():Bool {\r\n\t\treturn current < length;\r\n\t}\r\n\r\n\tpublic inline function next():String {\r\n\t\treturn keys[current++];\r\n\t}\r\n}\r\n\r\nprivate class StringMapValueIterator<T> {\r\n\tfinal h:Dynamic;\r\n\tfinal keys:Array<String>;\r\n\tfinal length:Int;\r\n\tvar current:Int;\r\n\r\n\tpublic inline function new(h:Dynamic) {\r\n\t\tthis.h = h;\r\n\t\tkeys = Object.keys(h);\r\n\t\tlength = keys.length;\r\n\t\tcurrent = 0;\r\n\t}\r\n\r\n\tpublic inline function hasNext():Bool {\r\n\t\treturn current < length;\r\n\t}\r\n\r\n\tpublic inline function next():T {\r\n\t\treturn h[cast keys[current++]];\r\n\t}\r\n}\r\n\r\nprivate class StringMapKeyValueIterator<T> {\r\n\tfinal h:Dynamic;\r\n\tfinal keys:Array<String>;\r\n\tfinal length:Int;\r\n\tvar current:Int;\r\n\r\n\tpublic inline function new(h:Dynamic) {\r\n\t\tthis.h = h;\r\n\t\tkeys = Object.keys(h);\r\n\t\tlength = keys.length;\r\n\t\tcurrent = 0;\r\n\t}\r\n\r\n\tpublic inline function hasNext():Bool {\r\n\t\treturn current < length;\r\n\t}\r\n\r\n\tpublic inline function next():{key:String, value:T} {\r\n\t\tvar key = keys[current++];\r\n\t\treturn {key: key, value: h[cast key]};\r\n\t}\r\n}\r\n#else\r\nprivate class StringMapIterator<T> {\r\n\tvar map:StringMap<T>;\r\n\tvar keys:Array<String>;\r\n\tvar index:Int;\r\n\tvar count:Int;\r\n\r\n\tpublic inline function new(map:StringMap<T>, keys:Array<String>) {\r\n\t\tthis.map = map;\r\n\t\tthis.keys = keys;\r\n\t\tthis.index = 0;\r\n\t\tthis.count = keys.length;\r\n\t}\r\n\r\n\tpublic inline function hasNext() {\r\n\t\treturn index < count;\r\n\t}\r\n\r\n\tpublic inline function next() {\r\n\t\treturn map.get(keys[index++]);\r\n\t}\r\n}\r\n\r\n@:coreApi class StringMap<T> implements haxe.Constraints.IMap<String, T> {\r\n\tprivate var h:Dynamic;\r\n\tprivate var rh:Dynamic;\r\n\r\n\tpublic inline function new():Void {\r\n\t\th = {};\r\n\t}\r\n\r\n\tinline function isReserved(key:String):Bool {\r\n\t\treturn js.Syntax.code(\"__map_reserved[{0}]\", key) != null;\r\n\t}\r\n\r\n\tpublic inline function set(key:String, value:T):Void {\r\n\t\tif (isReserved(key))\r\n\t\t\tsetReserved(key, value);\r\n\t\telse\r\n\t\t\th[cast key] = value;\r\n\t}\r\n\r\n\tpublic inline function get(key:String):Null<T> {\r\n\t\tif (isReserved(key))\r\n\t\t\treturn getReserved(key);\r\n\t\treturn h[cast key];\r\n\t}\r\n\r\n\tpublic inline function exists(key:String):Bool {\r\n\t\tif (isReserved(key))\r\n\t\t\treturn existsReserved(key);\r\n\t\treturn h.hasOwnProperty(key);\r\n\t}\r\n\r\n\tfunction setReserved(key:String, value:T):Void {\r\n\t\tif (rh == null)\r\n\t\t\trh = {};\r\n\t\trh[cast \"$\" + key] = value;\r\n\t}\r\n\r\n\tfunction getReserved(key:String):Null<T> {\r\n\t\treturn rh == null ? null : rh[cast \"$\" + key];\r\n\t}\r\n\r\n\tfunction existsReserved(key:String):Bool {\r\n\t\tif (rh == null)\r\n\t\t\treturn false;\r\n\t\treturn (cast rh).hasOwnProperty(\"$\" + key);\r\n\t}\r\n\r\n\tpublic function remove(key:String):Bool {\r\n\t\tif (isReserved(key)) {\r\n\t\t\tkey = \"$\" + key;\r\n\t\t\tif (rh == null || !rh.hasOwnProperty(key))\r\n\t\t\t\treturn false;\r\n\t\t\tjs.Syntax.delete(rh, key);\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tif (!h.hasOwnProperty(key))\r\n\t\t\t\treturn false;\r\n\t\t\tjs.Syntax.delete(h, key);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function keys():Iterator<String> {\r\n\t\treturn arrayKeys().iterator();\r\n\t}\r\n\r\n\tfunction arrayKeys():Array<String> {\r\n\t\tvar out = [];\r\n\t\tuntyped {\r\n\t\t\tjs.Syntax.code(\"for( var key in this.h ) {\");\r\n\t\t\tif (h.hasOwnProperty(key))\r\n\t\t\t\tout.push(key);\r\n\t\t\tjs.Syntax.code(\"}\");\r\n\t\t}\r\n\t\tif (rh != null)\r\n\t\t\tuntyped {\r\n\t\t\t\tjs.Syntax.code(\"for( var key in this.rh ) {\");\r\n\t\t\t\tif (key.charCodeAt(0) == \"$\".code)\r\n\t\t\t\t\tout.push(key.substr(1));\r\n\t\t\t\tjs.Syntax.code(\"}\");\r\n\t\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n\tpublic inline function iterator():Iterator<T> {\r\n\t\treturn new StringMapIterator(this, arrayKeys());\r\n\t}\r\n\r\n\t@:runtime public inline function keyValueIterator():KeyValueIterator<String, T> {\r\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\r\n\t}\r\n\r\n\tpublic function copy():StringMap<T> {\r\n\t\tvar copied = new StringMap();\r\n\t\tfor (key in keys())\r\n\t\t\tcopied.set(key, get(key));\r\n\t\treturn copied;\r\n\t}\r\n\r\n\tpublic function toString():String {\r\n\t\tvar s = new StringBuf();\r\n\t\ts.add(\"{\");\r\n\t\tvar keys = arrayKeys();\r\n\t\tfor (i in 0...keys.length) {\r\n\t\t\tvar k = keys[i];\r\n\t\t\ts.add(k);\r\n\t\t\ts.add(\" => \");\r\n\t\t\ts.add(Std.string(get(k)));\r\n\t\t\tif (i < keys.length - 1)\r\n\t\t\t\ts.add(\", \");\r\n\t\t}\r\n\t\ts.add(\"}\");\r\n\t\treturn s.toString();\r\n\t}\r\n\r\n\tpublic inline function clear():Void {\r\n\t\th = {};\r\n\t\trh = null;\r\n\t}\r\n\r\n\tstatic function __init__():Void {\r\n\t\tjs.Syntax.code(\"var __map_reserved = {};\");\r\n\t}\r\n}\r\n#end\r\n","package ecs.macros;\r\n\r\nimport haxe.ds.Option;\r\nimport haxe.macro.Type;\r\nimport haxe.macro.Context;\r\n\r\nusing Safety;\r\n\r\nprivate final components = new Map<String, { id : Int, type : Type }>();\r\n\r\nprivate var componentIncrementer = 0;\r\n\r\n/**\r\n * Returns the total number of unique components.\r\n */\r\nfunction getComponentCount()\r\n{\r\n    return componentIncrementer;\r\n}\r\n\r\nfunction getComponentMap()\r\n{\r\n    return components;\r\n}\r\n\r\n/**\r\n * Given a complex type it will return an integer representing that type.\r\n * If this type has not yet been seen the returned integer is stored for future lookups.\r\n * @param _ct ComplexType to get ID for.\r\n */\r\nfunction registerComponent(_hash : String, _type : Type) : Int\r\n{\r\n    return if (components.exists(_hash))\r\n    {\r\n        components.get(_hash).unsafe().id;\r\n    }\r\n    else\r\n    {\r\n        final id = componentIncrementer++;\r\n\r\n        components.set(_hash, { id : id, type : _type });\r\n\r\n        id;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the component ID of a complex type.\r\n * If the complex type has not been registered as a component `None` is returned.\r\n * @param _type Complex type of the component.\r\n * @return Option<Int>\r\n */\r\nfunction getComponentID(_type : String) : Option<Int>\r\n{\r\n    return if (components.exists(_type))\r\n    {\r\n        Some(components.get(_type).unsafe().id);\r\n    }\r\n    else\r\n    {\r\n        None;\r\n    }\r\n}","package ecs.macros;\r\n\r\nimport haxe.ds.Option;\r\nimport haxe.ds.ReadOnlyArray;\r\nimport ecs.macros.SystemMacros.FamilyDefinition;\r\n\r\nusing Lambda;\r\n\r\n/**\r\n * Map of family IDs keyed by concatenated component types which compose that family.\r\n */\r\nprivate final familyIDs = new Map<String, Int>();\r\n\r\n/**\r\n * Array of all family definitions. Index of each family is its unique ID.\r\n */\r\nprivate final familyDefinitions = new Array<FamilyDefinition>();\r\n\r\n/**\r\n * All family definitions keyed by the name of the system and its used typed variable name.\r\n * The definition objects are fetched from the `familyDefinition` array.\r\n */\r\nprivate final keyedFamilies = new Map<String, FamilyDefinition>();\r\n\r\n/**\r\n * Current family counter. Incremented each time a new family is encountered.\r\n */\r\nprivate var familyIncrementer = 0;\r\n\r\n/**\r\n * Returns the number of families registered.\r\n * Only safe to use in expression macros.\r\n */\r\nfunction getFamilyCount()\r\n{\r\n    return familyIncrementer;\r\n}\r\n\r\n/**\r\n * Returns all registered family definitions. Index of each family in the array is its unique ID.\r\n * Only safe to use in expression macros.\r\n * @return ReadOnlyArray<FamilyDefinition>\r\n */\r\nfunction getFamilies() : ReadOnlyArray<FamilyDefinition>\r\n{\r\n    return familyDefinitions;\r\n}\r\n\r\n/**\r\n * Returns an array of family IDs which request the resource with the provided ID.\r\n * @param _id Resource ID to search for in families.\r\n * @return ReadOnlyArray<Int>\r\n */\r\nfunction getFamilyIDsWithResource(_id : Int) : ReadOnlyArray<Int>\r\n{\r\n    final filtered = [];\r\n\r\n    for (idx => family in familyDefinitions)\r\n    {\r\n        if (family.resources.exists(f -> f.uID == _id))\r\n        {\r\n            filtered.push(idx);\r\n        }\r\n    }\r\n\r\n    return filtered;\r\n}\r\n\r\nfunction getFamilyIDsWithComponent(_id : Int) : ReadOnlyArray<Int>\r\n{\r\n    final filtered = [];\r\n\r\n    for (idx => family in familyDefinitions)\r\n    {\r\n        if (family.components.exists(f -> f.uID == _id))\r\n        {\r\n            filtered.push(idx);\r\n        }\r\n    }\r\n\r\n    return filtered;\r\n}\r\n\r\n/**\r\n * Find a family by its `class-variable` unique key.\r\n * Only safe to use in expression macros.\r\n * @param _key Unique key.\r\n * @return Option<FamilyDefinition>\r\n */\r\nfunction getFamilyByKey(_key : String) : Option<FamilyDefinition>\r\n{\r\n    return if (keyedFamilies.exists(_key))\r\n    {\r\n        Some(keyedFamilies.get(_key));\r\n    }\r\n    else\r\n    {\r\n        None;\r\n    }\r\n}\r\n\r\n/**\r\n * Stores the provided family if one with the same hash does not exist.\r\n * @param _key Unique `class-var` string key.\r\n * @param _family Family definition object.\r\n */\r\nfunction registerFamily(_key : String, _family : FamilyDefinition)\r\n{\r\n    final familyHash = hash(_family);\r\n\r\n    // Always store our new family regardless of if a matching family hash is found.\r\n    // This is because if we search by family key we care about the component variables names, not just their types.\r\n    keyedFamilies.set(_key, _family);\r\n\r\n    return if (familyIDs.exists(familyHash))\r\n    {\r\n        familyIDs.get(familyHash);\r\n    }\r\n    else\r\n    {\r\n        final id = familyIncrementer++;\r\n\r\n        familyIDs.set(familyHash, id);\r\n        familyDefinitions.push(_family);\r\n\r\n        id;\r\n    }\r\n}\r\n\r\nprivate function hash(_family : FamilyDefinition) : String\r\n{\r\n    final buffer = new StringBuf();\r\n\r\n    buffer.add('c:');\r\n    for (comp in _family.components)\r\n    {\r\n        buffer.add(comp.type);\r\n    }\r\n\r\n    buffer.add('r:');\r\n    for (res in _family.resources)\r\n    {\r\n        buffer.add(res.type);\r\n    }\r\n\r\n    return buffer.toString();\r\n}","package ecs.macros;\r\n\r\nimport haxe.ds.Option;\r\n\r\nusing Safety;\r\n\r\nprivate final resources = new Map<String, Int>();\r\n\r\nprivate var resourceIncrementer = 0;\r\n\r\n/**\r\n * Returns the total number of unique components.\r\n */\r\nfunction getResourceCount()\r\n{\r\n    return resourceIncrementer;\r\n}\r\n\r\nfunction getResourceMap()\r\n{\r\n    return resources;\r\n}\r\n\r\n/**\r\n * Given a complex type it will return an integer representing that type.\r\n * If this type has not yet been seen the returned integer is stored for future lookups.\r\n * @param _ct ComplexType to get ID for.\r\n */\r\nfunction getResourceID(_hash : String) : Option<Int>\r\n{\r\n    return if (resources.exists(_hash))\r\n    {\r\n        Some(resources.get(_hash));\r\n    }\r\n    else\r\n    {\r\n        None;\r\n    }\r\n}\r\n\r\nfunction registerResource(_hash : String)\r\n{\r\n    return if (!resources.exists(_hash))\r\n    {\r\n        final id = resourceIncrementer++;\r\n\r\n        resources.set(_hash, id);\r\n\r\n        id;\r\n    }\r\n    else\r\n    {\r\n        resources.get(_hash).unsafe();\r\n    }\r\n}","package ecs.macros;\r\n\r\nimport haxe.ds.ReadOnlyArray;\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.Context;\r\nimport ecs.ds.Result;\r\nimport ecs.macros.FamilyCache;\r\nimport ecs.macros.ResourceCache;\r\nimport ecs.macros.ComponentCache;\r\nimport haxe.macro.Type;\r\n\r\nusing Lambda;\r\nusing Safety;\r\nusing haxe.macro.Tools;\r\n\r\n/**\r\n * Stores the user specified name and the complex type of a requested component or resource.\r\n */\r\ntypedef FamilyField = {\r\n    final name : String;\r\n    final type : ComplexType;\r\n}\r\n\r\n/**\r\n * Stores all the info on a registered component or resource.\r\n */\r\ntypedef RegisteredField = {\r\n    final name : String;\r\n    final type : Type;\r\n    final hash : String;\r\n    final uID : Int;\r\n}\r\n\r\ntypedef FamilyError = {\r\n    final message : String;\r\n    final pos : Position;\r\n}\r\n\r\ntypedef FamilyDefinition = {\r\n    /**\r\n     * Name of this family.\r\n     */\r\n    final name : String;\r\n\r\n    /**\r\n     * All the static resources requested by this family.\r\n     */\r\n    final resources : ReadOnlyArray<RegisteredField>;\r\n\r\n    /**\r\n     * All of the components requested by this family.\r\n     */\r\n    final components : ReadOnlyArray<RegisteredField>;\r\n}\r\n\r\nmacro function familyConstruction() : Array<Field>\r\n{\r\n    final fields = Context.getBuildFields();\r\n    final output = [];\r\n\r\n    final added    = getOrCreateOverrideFunction('onAdded', fields, Context.currentPos());\r\n    final removed  = getOrCreateOverrideFunction('onRemoved', fields, Context.currentPos());\r\n    final families = new Array<FamilyDefinition>();\r\n\r\n    for (field in fields)\r\n    {\r\n        if (hasMeta(field, ':fastFamily'))\r\n        {\r\n            switch extractFastFamily(field)\r\n            {\r\n                case Ok(data):\r\n                    families.push({\r\n                        name       : field.name,\r\n                        components : data.map(f -> {\r\n                            final resolved  = Context.resolveType(f.type, field.pos);\r\n                            final signature = Utils.signature(resolved);\r\n\r\n                            return {\r\n                                name : f.name,\r\n                                type : resolved,\r\n                                uID  : registerComponent(signature, resolved),\r\n                                hash : signature\r\n                            };\r\n                        }),\r\n                        resources  : []\r\n                    });\r\n                case Error(error): Context.error(error.message, error.pos);\r\n            }\r\n        }\r\n        else if (hasMeta(field, ':fullFamily'))\r\n        {\r\n            switch extractFullFamily(field)\r\n            {\r\n                case Ok(data):\r\n                    families.push({\r\n                        name       : data.name,\r\n                        components : switch data.components\r\n                        {\r\n                            case Ok(array): array.map(f -> {\r\n                                final resolved  = Context.resolveType(f.type, field.pos);\r\n                                final signature = Utils.signature(resolved);\r\n\r\n                                return {\r\n                                    name : f.name,\r\n                                    type : resolved,\r\n                                    uID  : registerComponent(signature, resolved),\r\n                                    hash : signature\r\n                                };\r\n                            });\r\n                            case Error(error): Context.error(error.message, error.pos);\r\n                        },\r\n                        resources : switch data.resources\r\n                        {\r\n                            case Ok(array): array.map(f -> {\r\n                                final resolved  = Context.resolveType(f.type, field.pos);\r\n                                final signature = Utils.signature(resolved);\r\n\r\n                                return {\r\n                                    name : f.name,\r\n                                    type : resolved,\r\n                                    uID  : registerResource(signature),\r\n                                    hash : signature\r\n                                };\r\n                            });\r\n                            case Error(error): Context.error(error.message, error.pos);\r\n                        }\r\n                    });\r\n                case Error(error): Context.error(error.message, field.pos);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            output.push(field);\r\n        }\r\n    }\r\n\r\n    // First pass over the extracted families we define a new family field in the system for that type.\r\n    // We also add a call to get that family from the world at the top of the `onAdded` function.\r\n    for (idx => family in families)\r\n    {\r\n        output.push({\r\n            name : family.name,\r\n            pos  : Context.currentPos(),\r\n            kind : FVar(macro : ecs.Family)\r\n        });\r\n\r\n        // Insert out `family.get` calls at the very top of the `onAdded` function.\r\n        // This we we can always access them in a overridden `onAdded`.\r\n\r\n        final clsKey = '${ Utils.signature(Context.getLocalType()) }-${ family.name }';\r\n\r\n        insertExprIntoFunction(idx, added, macro $i{ family.name } = universe.families.get($v{ registerFamily(clsKey, family) }));\r\n    }\r\n\r\n    // For all unique components add a `Components<T>` member field and insert a call to populate it in the `onAdded` function.\r\n    for (idx => component in getUniqueComponents(families))\r\n    {\r\n        final ct   = component.type.toComplexType();\r\n        final name = 'table${ component.hash }';\r\n\r\n        output.push({\r\n            name : name,\r\n            pos  : Context.currentPos(),\r\n            kind : FVar(macro : ecs.Components<$ct>),\r\n        });\r\n\r\n        // Inserting at `families.length + idx` ensures all out `getTable` calls happen after the families are fetched.\r\n        insertExprIntoFunction(\r\n            families.length + idx,\r\n            added,\r\n            macro $i{ name } = cast universe.components.getTable($v{ component.uID }));\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\n/**\r\n * Search the array of fields for one with a name that matches the provided string.\r\n * If no matching field is found a public override field with that name is appended to the field array.\r\n * @param _name Name to search for / create if not found.\r\n * @param _fields Existing fields.\r\n * @param _pos Context.currentPos()\r\n * @return Either the found field or the newly creatd one.\r\n */\r\nprivate function getOrCreateOverrideFunction(_name : String, _fields : Array<Field>, _pos : Position)\r\n{\r\n    for (field in _fields)\r\n    {\r\n        if (field.name == _name)\r\n        {\r\n            return field;\r\n        }\r\n    }\r\n\r\n    _fields.push({\r\n        name   : _name,\r\n        access : [ APublic, AOverride ],\r\n        pos    : _pos,\r\n        kind   : FFun({ args : [], expr : macro {} })\r\n    });\r\n\r\n    return _fields[_fields.length - 1];\r\n}\r\n\r\n/**\r\n * Inserts an expression into a function block field.\r\n * @param _pos Position within the existing expression array to insert at.\r\n * @param _field Field to insert in, must be a FFun EBlock field.\r\n * @param _expr Expression to insert.\r\n */\r\nprivate function insertExprIntoFunction(_pos : Int, _field : Field, _expr : Expr)\r\n{\r\n    switch _field.kind\r\n    {\r\n        case FFun(f):\r\n            switch f.expr.expr\r\n            {\r\n                case EBlock(exprs): exprs.insert(_pos, _expr);\r\n                case _:\r\n            }\r\n        case _:\r\n    }\r\n}\r\n\r\n/**\r\n * Returns if a field has the provided metadata string.\r\n * @param _field Field to check.\r\n * @param _meta Meta data name.\r\n */\r\nprivate function hasMeta(_field : Field, _meta : String)\r\n{\r\n    if (_field.meta == null || _field.meta.length == 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    for (meta in _field.meta)\r\n    {\r\n        if (meta.name == _meta)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Given a field it will attempt to extract a family definition from just the requested components.\r\n * Empty arrays will be used for the resources and exclusions.\r\n * An error will be returned if any unexpected expression types are encountered.\r\n * @param _field Field to check.\r\n * @return Result<FamilyDefinition, String>\r\n */\r\nprivate function extractFastFamily(_field : Field)\r\n{\r\n    return switch _field.kind\r\n    {\r\n        case FVar(TAnonymous(fields), _): extractFamilyComponentsFromObject(fields);\r\n        case other: Error({ message : 'Unexpected field kind $other, expected FVar', pos : _field.pos });\r\n    }\r\n}\r\n\r\n/**\r\n * Given a field it will attempt to extract a fully defined family from the expression within.\r\n * If any part of the definition is missing an empty array will be used in its place.\r\n * An error will be returned if any unexpected expression types are encountered.\r\n * @param _field Field to check.\r\n * @return Result<FamilyDefinition, String>\r\n */\r\nprivate function extractFullFamily(_field : Field) : Result<{ name : String, components : Result<ReadOnlyArray<FamilyField>, FamilyError>, resources : Result<ReadOnlyArray<FamilyField>, FamilyError> }, FamilyError>\r\n{\r\n    return switch _field.kind\r\n    {\r\n        case FVar(TAnonymous(fields), _):\r\n            final requires = fields\r\n                .find(f -> f.name == 'requires')\r\n                .let(f -> switch f.kind\r\n                    {\r\n                        case FVar(TAnonymous(fields), _): extractFamilyComponentsFromObject(fields);\r\n                        case other: Error({ message : 'Unexpected object field expression $other', pos : f.pos });\r\n                    })\r\n                .or(Ok([]));\r\n            final resources = fields\r\n                .find(f -> f.name == 'resources')\r\n                .let(f -> switch f.kind\r\n                    {\r\n                        case FVar(TAnonymous(fields), _): extractFamilyComponentsFromObject(fields);\r\n                        case other: Error({ message : 'Unexpected object field expression $other', pos : f.pos });\r\n                    })\r\n                .or(Ok([]));\r\n\r\n            Ok({\r\n                name       : _field.name,\r\n                components : requires,\r\n                resources  : resources\r\n            });\r\n        case other: Error({ message : 'Unexpected field kind ${ other }, expected FVar', pos : _field.pos });\r\n    }\r\n}\r\n\r\n/**\r\n * Extracts all the `EConst(CIdent(_))` names from an array of object fields.\r\n * Returned family fields are lexographically ordered by their name.\r\n * If any other expressions are found an error is returned.\r\n * @param _fields Object fields to search through.\r\n * @return Result<ReadOnlyArray<FamilyField>, Exception>\r\n */\r\nprivate function extractFamilyComponentsFromObject(_fields : ReadOnlyArray<Field>) : Result<ReadOnlyArray<FamilyField>, FamilyError>\r\n{\r\n    final extracted = new Array<FamilyField>();\r\n\r\n    for (field in _fields)\r\n    {\r\n        switch field.kind\r\n        {\r\n            case FVar(ct, _):\r\n                extracted.push({\r\n                    name : field.name,\r\n                    type : ct\r\n                });\r\n            case other:\r\n                return Error({ message : 'Unexpected expression ${ other }, expected FVar(_, EConst(CIdent(_)))', pos : field.pos });\r\n        }\r\n    }\r\n\r\n    extracted.sort(sort);\r\n\r\n    return Ok(extracted);\r\n}\r\n\r\n/**\r\n * Given a number of families returns all unique components requested by all of them.\r\n * This function checks by type not component variable name.\r\n * @param _families Families to search.\r\n * @return ReadOnlyArray<FamilyField>\r\n */\r\nprivate function getUniqueComponents(_families : ReadOnlyArray<FamilyDefinition>) : ReadOnlyArray<RegisteredField>\r\n{\r\n    final components = new Array<RegisteredField>();\r\n\r\n    for (family in _families)\r\n    {\r\n        for (component in family.components)\r\n        {\r\n            if (!components.exists(f -> f.uID == component.uID))\r\n            {\r\n                components.push(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    return components;\r\n}\r\n\r\n/**\r\n * Function to sort two objects based on a name field.\r\n * @param o1 Object 1.\r\n * @param o2 Object 2.\r\n */\r\nprivate function sort(o1 : Dynamic, o2 : Dynamic)\r\n{\r\n    final name1 = o1.type;\r\n    final name2 = o2.type;\r\n\r\n    if (name1 < name2)\r\n    {\r\n        return -1;\r\n    }\r\n    if (name1 > name2)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    return 0;\r\n}","package haxe;\r\n\r\nimport js.lib.Error;\r\n\r\n@:coreApi\r\nclass Exception extends NativeException {\r\n\tpublic var message(get,never):String;\r\n\tpublic var stack(get,never):CallStack;\r\n\tpublic var previous(get,never):Null<Exception>;\r\n\tpublic var native(get,never):Any;\r\n\r\n\t@:ifFeature(\"haxe.Exception.get_stack\")\r\n\t@:noCompletion var __skipStack:Int;\r\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\r\n\t@:noCompletion var __nativeException:Any;\r\n\t@:noCompletion var __previousException:Null<Exception>;\r\n\r\n\tstatic function caught(value:Any):Exception {\r\n\t\tif(Std.isOfType(value, Exception)) {\r\n\t\t\treturn value;\r\n\t\t} else if(Std.isOfType(value, Error)) {\r\n\t\t\treturn new Exception((cast value:Error).message, null, value);\r\n\t\t} else {\r\n\t\t\treturn new ValueException(value, null, value);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic function thrown(value:Any):Any {\r\n\t\tif(Std.isOfType(value, Exception)) {\r\n\t\t\treturn (value:Exception).native;\r\n\t\t} else if(Std.isOfType(value, Error)) {\r\n\t\t\treturn value;\r\n\t\t} else {\r\n\t\t\tvar e = new ValueException(value);\r\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\r\n\t\t\treturn e;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\r\n\t\tsuper(message);\r\n\t\t(cast this).message = message;\r\n\t\t__previousException = previous;\r\n\t\t__nativeException = native != null ? native : this;\r\n\t\tuntyped __feature__('haxe.Exception.stack', {\r\n\t\t\t__skipStack = 0;\r\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\r\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\r\n\t\t\tif(Std.isOfType(native, Error)) {\r\n\t\t\t\t(cast this).stack = native.stack;\r\n\t\t\t} else {\r\n\t\t\t\tvar e:Error = null;\r\n\t\t\t\tif ((cast Error).captureStackTrace) {\r\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\r\n\t\t\t\t\te = cast this;\r\n\t\t\t\t} else {\r\n\t\t\t\t\te = new Error();\r\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\r\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\r\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\r\n\t\t\t\t\t\t__skipStack++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t(cast this).stack = e.stack;\r\n\t\t\t}\r\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\r\n\t\t});\r\n\t}\r\n\r\n\tfunction unwrap():Any {\r\n\t\treturn __nativeException;\r\n\t}\r\n\r\n\tpublic function toString():String {\r\n\t\treturn message;\r\n\t}\r\n\r\n\tpublic function details():String {\r\n\t\treturn inline CallStack.exceptionToString(this);\r\n\t}\r\n\r\n\t@:noCompletion\r\n\t@:ifFeature(\"haxe.Exception.get_stack\")\r\n\tinline function __shiftStack():Void {\r\n\t\t__skipStack++;\r\n\t}\r\n\r\n\tfunction get_message():String {\r\n\t\treturn (cast this:Error).message;\r\n\t}\r\n\r\n\tfunction get_previous():Null<Exception> {\r\n\t\treturn __previousException;\r\n\t}\r\n\r\n\tfinal function get_native():Any {\r\n\t\treturn __nativeException;\r\n\t}\r\n\r\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\r\n\tfunction get_stack():CallStack {\r\n\t\treturn switch __exceptionStack {\r\n\t\t\tcase null:\r\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\r\n\t\t\tcase s: s;\r\n\t\t}\r\n\t}\r\n\r\n\t@:noCompletion\r\n\tfunction setProperty(name:String, value:Any):Void {\r\n\t\ttry {\r\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\r\n\t\t} catch(e:Exception) {\r\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\r\n\t\t}\r\n\t}\r\n\r\n\t@:noCompletion\r\n\tinline function get___exceptionStack():CallStack {\r\n\t\treturn (cast this).__exceptionStack;\r\n\t}\r\n\r\n\t@:noCompletion\r\n\tinline function set___exceptionStack(value:CallStack):CallStack {\r\n\t\tsetProperty('__exceptionStack', value);\r\n\t\treturn value;\r\n\t}\r\n\r\n\t@:noCompletion\r\n\tinline function get___skipStack():Int {\r\n\t\treturn (cast this).__skipStack;\r\n\t}\r\n\r\n\t@:noCompletion\r\n\tinline function set___skipStack(value:Int):Int {\r\n\t\tsetProperty('__skipStack', value);\r\n\t\treturn value;\r\n\t}\r\n\r\n\t@:noCompletion\r\n\tinline function get___nativeException():Any {\r\n\t\treturn (cast this).__nativeException;\r\n\t}\r\n\r\n\t@:noCompletion\r\n\tinline function set___nativeException(value:Any):Any {\r\n\t\tsetProperty('__nativeException', value);\r\n\t\treturn value;\r\n\t}\r\n\r\n\t@:noCompletion\r\n\tinline function get___previousException():Null<Exception> {\r\n\t\treturn (cast this).__previousException;\r\n\t}\r\n\r\n\t@:noCompletion\r\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\r\n\t\tsetProperty('__previousException', value);\r\n\t\treturn value;\r\n\t}\r\n}\r\n\r\n@:dox(hide)\r\n@:noCompletion\r\n@:native('Error')\r\nprivate extern class NativeException {\r\n\t// private var message:String; //redefined in haxe.Exception\r\n\t// private var stack(default, null):String; //redefined in haxe.Exception\r\n\r\n\tfunction new(?message:String);\r\n}\r\n","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage haxe;\r\n\r\n/**\r\n\tLog primarily provides the `trace()` method, which is invoked upon a call to\r\n\t`trace()` in Haxe code.\r\n**/\r\nclass Log {\r\n\t/**\r\n\t\tFormat the output of `trace` before printing it.\r\n\t**/\r\n\tpublic static function formatOutput(v:Dynamic, infos:PosInfos):String {\r\n\t\tvar str = Std.string(v);\r\n\t\tif (infos == null)\r\n\t\t\treturn str;\r\n\t\tvar pstr = infos.fileName + \":\" + infos.lineNumber;\r\n\t\tif (infos.customParams != null)\r\n\t\t\tfor (v in infos.customParams)\r\n\t\t\t\tstr += \", \" + Std.string(v);\r\n\t\treturn pstr + \": \" + str;\r\n\t}\r\n\r\n\t/**\r\n\t\tOutputs `v` in a platform-dependent way.\r\n\r\n\t\tThe second parameter `infos` is injected by the compiler and contains\r\n\t\tinformation about the position where the `trace()` call was made.\r\n\r\n\t\tThis method can be rebound to a custom function:\r\n\r\n\t\t\tvar oldTrace = haxe.Log.trace; // store old function\r\n\t\t\thaxe.Log.trace = function(v, ?infos) {\r\n\t\t\t  // handle trace\r\n\t\t\t}\r\n\t\t\t...\r\n\t\t\thaxe.Log.trace = oldTrace;\r\n\r\n\t\tIf it is bound to null, subsequent calls to `trace()` will cause an\r\n\t\texception.\r\n\t**/\r\n\tpublic static dynamic function trace(v:Dynamic, ?infos:PosInfos):Void {\r\n\t\tvar str = formatOutput(v, infos);\r\n\t\t#if js\r\n\t\tif (js.Syntax.typeof(untyped console) != \"undefined\" && (untyped console).log != null)\r\n\t\t\t(untyped console).log(str);\r\n\t\t#elseif lua\r\n\t\tuntyped __define_feature__(\"use._hx_print\", _hx_print(str));\r\n\t\t#elseif sys\r\n\t\tSys.println(str);\r\n\t\t#else\r\n\t\tthrow new haxe.exceptions.NotImplementedException()\r\n\t\t#end\r\n\t}\r\n}\r\n","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage haxe;\r\n\r\n#if (target.threaded && !cppia)\r\nimport sys.thread.Thread;\r\nimport sys.thread.EventLoop;\r\n#end\r\n\r\n/**\r\n\tThe `Timer` class allows you to create asynchronous timers on platforms that\r\n\tsupport events.\r\n\r\n\tThe intended usage is to create an instance of the `Timer` class with a given\r\n\tinterval, set its `run()` method to a custom function to be invoked and\r\n\teventually call `stop()` to stop the `Timer`.\r\n\r\n\tNote that a running `Timer` may or may not prevent the program to exit\r\n\tautomatically when `main()` returns.\r\n\r\n\tIt is also possible to extend this class and override its `run()` method in\r\n\tthe child class.\r\n**/\r\nclass Timer {\r\n\t#if (flash || js)\r\n\tprivate var id:Null<Int>;\r\n\t#elseif (target.threaded && !cppia)\r\n\tvar thread:Thread;\r\n\tvar eventHandler:EventHandler;\r\n\t#else\r\n\tprivate var event:MainLoop.MainEvent;\r\n\t#end\r\n\r\n\t/**\r\n\t\tCreates a new timer that will run every `time_ms` milliseconds.\r\n\r\n\t\tAfter creating the Timer instance, it calls `this.run` repeatedly,\r\n\t\twith delays of `time_ms` milliseconds, until `this.stop` is called.\r\n\r\n\t\tThe first invocation occurs after `time_ms` milliseconds, not\r\n\t\timmediately.\r\n\r\n\t\tThe accuracy of this may be platform-dependent.\r\n\t**/\r\n\tpublic function new(time_ms:Int) {\r\n\t\t#if flash\r\n\t\tvar me = this;\r\n\t\tid = untyped __global__[\"flash.utils.setInterval\"](function() {\r\n\t\t\tme.run();\r\n\t\t}, time_ms);\r\n\t\t#elseif js\r\n\t\tvar me = this;\r\n\t\tid = untyped setInterval(function() me.run(), time_ms);\r\n\t\t#elseif (target.threaded && !cppia)\r\n\t\tthread = Thread.current();\r\n\t\teventHandler = thread.events.repeat(() -> this.run(), time_ms);\r\n\t\t#else\r\n\t\tvar dt = time_ms / 1000;\r\n\t\tevent = MainLoop.add(function() {\r\n\t\t\t@:privateAccess event.nextRun += dt;\r\n\t\t\trun();\r\n\t\t});\r\n\t\tevent.delay(dt);\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tStops `this` Timer.\r\n\r\n\t\tAfter calling this method, no additional invocations of `this.run`\r\n\t\twill occur.\r\n\r\n\t\tIt is not possible to restart `this` Timer once stopped.\r\n\t**/\r\n\tpublic function stop() {\r\n\t\t#if (flash || js)\r\n\t\tif (id == null)\r\n\t\t\treturn;\r\n\t\t#if flash\r\n\t\tuntyped __global__[\"flash.utils.clearInterval\"](id);\r\n\t\t#elseif js\r\n\t\tuntyped clearInterval(id);\r\n\t\t#end\r\n\t\tid = null;\r\n\t\t#elseif (target.threaded && !cppia)\r\n\t\tthread.events.cancel(eventHandler);\r\n\t\t#else\r\n\t\tif (event != null) {\r\n\t\t\tevent.stop();\r\n\t\t\tevent = null;\r\n\t\t}\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tThis method is invoked repeatedly on `this` Timer.\r\n\r\n\t\tIt can be overridden in a subclass, or rebound directly to a custom\r\n\t\tfunction:\r\n\r\n\t\t```haxe\r\n\t\tvar timer = new haxe.Timer(1000); // 1000ms delay\r\n\t\ttimer.run = function() { ... }\r\n\t\t```\r\n\r\n\t\tOnce bound, it can still be rebound to different functions until `this`\r\n\t\tTimer is stopped through a call to `this.stop`.\r\n\t**/\r\n\tpublic dynamic function run() {}\r\n\r\n\t/**\r\n\t\tInvokes `f` after `time_ms` milliseconds.\r\n\r\n\t\tThis is a convenience function for creating a new Timer instance with\r\n\t\t`time_ms` as argument, binding its `run()` method to `f` and then stopping\r\n\t\t`this` Timer upon the first invocation.\r\n\r\n\t\tIf `f` is `null`, the result is unspecified.\r\n\t**/\r\n\tpublic static function delay(f:Void->Void, time_ms:Int) {\r\n\t\tvar t = new haxe.Timer(time_ms);\r\n\t\tt.run = function() {\r\n\t\t\tt.stop();\r\n\t\t\tf();\r\n\t\t};\r\n\t\treturn t;\r\n\t}\r\n\r\n\t/**\r\n\t\tMeasures the time it takes to execute `f`, in seconds with fractions.\r\n\r\n\t\tThis is a convenience function for calculating the difference between\r\n\t\t`Timer.stamp()` before and after the invocation of `f`.\r\n\r\n\t\tThe difference is passed as argument to `Log.trace()`, with `\"s\"` appended\r\n\t\tto denote the unit. The optional `pos` argument is passed through.\r\n\r\n\t\tIf `f` is `null`, the result is unspecified.\r\n\t**/\r\n\tpublic static function measure<T>(f:Void->T, ?pos:PosInfos):T {\r\n\t\tvar t0 = stamp();\r\n\t\tvar r = f();\r\n\t\tLog.trace((stamp() - t0) + \"s\", pos);\r\n\t\treturn r;\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns a timestamp, in seconds with fractions.\r\n\r\n\t\tThe value itself might differ depending on platforms, only differences\r\n\t\tbetween two values make sense.\r\n\t**/\r\n\tpublic static inline function stamp():Float {\r\n\t\t#if flash\r\n\t\treturn flash.Lib.getTimer() / 1000;\r\n\t\t#elseif js\r\n\t\t#if nodejs\r\n\t\tvar hrtime = js.Syntax.code('process.hrtime()'); // [seconds, remaining nanoseconds]\r\n\t\treturn hrtime[0] + hrtime[1] / 1e9;\r\n\t\t#else\r\n\t\treturn @:privateAccess HxOverrides.now() / 1000;\r\n\t\t#end\r\n\t\t#elseif cpp\r\n\t\treturn untyped __global__.__time_stamp();\r\n\t\t#elseif python\r\n\t\treturn Sys.cpuTime();\r\n\t\t#elseif sys\r\n\t\treturn Sys.time();\r\n\t\t#else\r\n\t\treturn 0;\r\n\t\t#end\r\n\t}\r\n}","package haxe;\r\n\r\n/**\r\n\tAn exception containing arbitrary value.\r\n\r\n\tThis class is automatically used for throwing values, which don't extend `haxe.Exception`\r\n\tor native exception type.\r\n\tFor example:\r\n\t```haxe\r\n\tthrow \"Terrible error\";\r\n\t```\r\n\twill be compiled to\r\n\t```haxe\r\n\tthrow new ValueException(\"Terrible error\");\r\n\t```\r\n**/\r\nclass ValueException extends Exception {\r\n\t/**\r\n\t\tThrown value.\r\n\t**/\r\n\tpublic var value(default,null):Any;\r\n\r\n\tpublic function new(value:Any, ?previous:Exception, ?native:Any):Void {\r\n\t\tsuper(#if js js.Syntax.code('String({0})', value) #else Std.string(value) #end, previous, native);\r\n\t\tthis.value = value;\r\n\t}\r\n\r\n\t/**\r\n\t\tExtract an originally thrown value.\r\n\r\n\t\tThis method must return the same value on subsequent calls.\r\n\t\tUsed internally for catching non-native exceptions.\r\n\t\tDo _not_ override unless you know what you are doing.\r\n\t**/\r\n\toverride function unwrap():Any {\r\n\t\treturn value;\r\n\t}\r\n}","package haxe.exceptions;\r\n\r\n/**\r\n\tAn exception that carry position information of a place where it was created.\r\n**/\r\nclass PosException extends Exception {\r\n\t/**\r\n\t\tPosition where this exception was created.\r\n\t**/\r\n\tpublic final posInfos:PosInfos;\r\n\r\n\tpublic function new(message:String, ?previous:Exception, ?pos:PosInfos):Void {\r\n\t\tsuper(message, previous);\r\n\t\tif (pos == null) {\r\n\t\t\tposInfos = { fileName:'(unknown)', lineNumber:0, className:'(unknown)', methodName:'(unknown)' }\r\n\t\t} else {\r\n\t\t\tposInfos = pos;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns exception message.\r\n\t**/\r\n\toverride function toString():String {\r\n\t\treturn '${super.toString()} in ${posInfos.className}.${posInfos.methodName} at ${posInfos.fileName}:${posInfos.lineNumber}';\r\n\t}\r\n}","package haxe.exceptions;\r\n\r\n/**\r\n\tAn exception that is thrown when requested function or operation does not have an implementation.\r\n**/\r\nclass NotImplementedException extends PosException {\r\n\tpublic function new(message:String = 'Not implemented', ?previous:Exception, ?pos:PosInfos):Void {\r\n\t\tsuper(message, previous, pos);\r\n\t}\r\n}","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage haxe.io;\r\n\r\n@:coreApi\r\nclass Bytes {\r\n\tpublic var length(default, null):Int;\r\n\r\n\tvar b:js.lib.Uint8Array;\r\n\tvar data:js.lib.DataView;\r\n\r\n\tfunction new(data:BytesData) {\r\n\t\tthis.length = data.byteLength;\r\n\t\tthis.b = new js.lib.Uint8Array(data);\r\n\t\tuntyped {\r\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\r\n\t\t\tdata.hxBytes = this;\r\n\t\t\tdata.bytes = this.b;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic inline function get(pos:Int):Int {\r\n\t\treturn b[pos];\r\n\t}\r\n\r\n\tpublic inline function set(pos:Int, v:Int):Void {\r\n\t\tb[pos] = v;\r\n\t}\r\n\r\n\tpublic function blit(pos:Int, src:Bytes, srcpos:Int, len:Int):Void {\r\n\t\tif (pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length)\r\n\t\t\tthrow Error.OutsideBounds;\r\n\t\tif (srcpos == 0 && len == src.b.byteLength)\r\n\t\t\tb.set(src.b, pos);\r\n\t\telse\r\n\t\t\tb.set(src.b.subarray(srcpos, srcpos + len), pos);\r\n\t}\r\n\r\n\tpublic function fill(pos:Int, len:Int, value:Int):Void {\r\n\t\tfor (i in 0...len)\r\n\t\t\tset(pos++, value);\r\n\t}\r\n\r\n\tpublic function sub(pos:Int, len:Int):Bytes {\r\n\t\tif (pos < 0 || len < 0 || pos + len > length)\r\n\t\t\tthrow Error.OutsideBounds;\r\n\t\treturn new Bytes(b.buffer.slice(pos + b.byteOffset, pos + b.byteOffset + len));\r\n\t}\r\n\r\n\tpublic function compare(other:Bytes):Int {\r\n\t\tvar b1 = b;\r\n\t\tvar b2 = other.b;\r\n\t\tvar len = (length < other.length) ? length : other.length;\r\n\t\tfor (i in 0...len)\r\n\t\t\tif (b1[i] != b2[i])\r\n\t\t\t\treturn b1[i] - b2[i];\r\n\t\treturn length - other.length;\r\n\t}\r\n\r\n\tinline function initData():Void {\r\n\t\tif (data == null)\r\n\t\t\tdata = new js.lib.DataView(b.buffer, b.byteOffset, b.byteLength);\r\n\t}\r\n\r\n\tpublic function getDouble(pos:Int):Float {\r\n\t\tinitData();\r\n\t\treturn data.getFloat64(pos, true);\r\n\t}\r\n\r\n\tpublic function getFloat(pos:Int):Float {\r\n\t\tinitData();\r\n\t\treturn data.getFloat32(pos, true);\r\n\t}\r\n\r\n\tpublic function setDouble(pos:Int, v:Float):Void {\r\n\t\tinitData();\r\n\t\tdata.setFloat64(pos, v, true);\r\n\t}\r\n\r\n\tpublic function setFloat(pos:Int, v:Float):Void {\r\n\t\tinitData();\r\n\t\tdata.setFloat32(pos, v, true);\r\n\t}\r\n\r\n\tpublic function getUInt16(pos:Int):Int {\r\n\t\tinitData();\r\n\t\treturn data.getUint16(pos, true);\r\n\t}\r\n\r\n\tpublic function setUInt16(pos:Int, v:Int):Void {\r\n\t\tinitData();\r\n\t\tdata.setUint16(pos, v, true);\r\n\t}\r\n\r\n\tpublic function getInt32(pos:Int):Int {\r\n\t\tinitData();\r\n\t\treturn data.getInt32(pos, true);\r\n\t}\r\n\r\n\tpublic function setInt32(pos:Int, v:Int):Void {\r\n\t\tinitData();\r\n\t\tdata.setInt32(pos, v, true);\r\n\t}\r\n\r\n\tpublic function getInt64(pos:Int):haxe.Int64 {\r\n\t\treturn Int64.make(getInt32(pos + 4), getInt32(pos));\r\n\t}\r\n\r\n\tpublic function setInt64(pos:Int, v:haxe.Int64):Void {\r\n\t\tsetInt32(pos, v.low);\r\n\t\tsetInt32(pos + 4, v.high);\r\n\t}\r\n\r\n\tpublic function getString(pos:Int, len:Int, ?encoding:Encoding):String {\r\n\t\tif (pos < 0 || len < 0 || pos + len > length)\r\n\t\t\tthrow Error.OutsideBounds;\r\n\t\tif (encoding == null)\r\n\t\t\tencoding = UTF8;\r\n\t\tvar s = \"\";\r\n\t\tvar b = b;\r\n\t\tvar i = pos;\r\n\t\tvar max = pos + len;\r\n\t\tswitch (encoding) {\r\n\t\t\tcase UTF8:\r\n\t\t\t\tvar debug = pos > 0;\r\n\t\t\t\t// utf8-decode and utf16-encode\r\n\t\t\t\twhile (i < max) {\r\n\t\t\t\t\tvar c = b[i++];\r\n\t\t\t\t\tif (c < 0x80) {\r\n\t\t\t\t\t\tif (c == 0)\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\ts += String.fromCharCode(c);\r\n\t\t\t\t\t} else if (c < 0xE0)\r\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x3F) << 6) | (b[i++] & 0x7F));\r\n\t\t\t\t\telse if (c < 0xF0) {\r\n\t\t\t\t\t\tvar c2 = b[i++];\r\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar c2 = b[i++];\r\n\t\t\t\t\t\tvar c3 = b[i++];\r\n\t\t\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\r\n\t\t\t\t\t\ts += String.fromCharCode(u);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\tcase RawNative:\r\n\t\t\t\twhile (i < max) {\r\n\t\t\t\t\tvar c = b[i++] | (b[i++] << 8);\r\n\t\t\t\t\ts += String.fromCharCode(c);\r\n\t\t\t\t}\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\r\n\t@:deprecated(\"readString is deprecated, use getString instead\")\r\n\t@:noCompletion\r\n\tpublic inline function readString(pos:Int, len:Int):String {\r\n\t\treturn getString(pos, len);\r\n\t}\r\n\r\n\tpublic function toString():String {\r\n\t\treturn getString(0, length);\r\n\t}\r\n\r\n\tpublic function toHex():String {\r\n\t\tvar s = new StringBuf();\r\n\t\tvar chars = [];\r\n\t\tvar str = \"0123456789abcdef\";\r\n\t\tfor (i in 0...str.length)\r\n\t\t\tchars.push(str.charCodeAt(i));\r\n\t\tfor (i in 0...length) {\r\n\t\t\tvar c = get(i);\r\n\t\t\ts.addChar(chars[c >> 4]);\r\n\t\t\ts.addChar(chars[c & 15]);\r\n\t\t}\r\n\t\treturn s.toString();\r\n\t}\r\n\r\n\tpublic inline function getData():BytesData {\r\n\t\treturn untyped b.bufferValue;\r\n\t}\r\n\r\n\tpublic static inline function alloc(length:Int):Bytes {\r\n\t\treturn new Bytes(new BytesData(length));\r\n\t}\r\n\r\n\tpublic static function ofString(s:String, ?encoding:Encoding):Bytes {\r\n\t\tif (encoding == RawNative) {\r\n\t\t\tvar buf = new js.lib.Uint8Array(s.length << 1);\r\n\t\t\tfor (i in 0...s.length) {\r\n\t\t\t\tvar c:Int = StringTools.fastCodeAt(s, i);\r\n\t\t\t\tbuf[i << 1] = c & 0xFF;\r\n\t\t\t\tbuf[(i << 1) | 1] = c >> 8;\r\n\t\t\t}\r\n\t\t\treturn new Bytes(buf.buffer);\r\n\t\t}\r\n\t\tvar a = new Array();\r\n\t\t// utf16-decode and utf8-encode\r\n\t\tvar i = 0;\r\n\t\twhile (i < s.length) {\r\n\t\t\tvar c:Int = StringTools.fastCodeAt(s, i++);\r\n\t\t\t// surrogate pair\r\n\t\t\tif (0xD800 <= c && c <= 0xDBFF)\r\n\t\t\t\tc = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s, i++) & 0x3FF);\r\n\t\t\tif (c <= 0x7F)\r\n\t\t\t\ta.push(c);\r\n\t\t\telse if (c <= 0x7FF) {\r\n\t\t\t\ta.push(0xC0 | (c >> 6));\r\n\t\t\t\ta.push(0x80 | (c & 63));\r\n\t\t\t} else if (c <= 0xFFFF) {\r\n\t\t\t\ta.push(0xE0 | (c >> 12));\r\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\r\n\t\t\t\ta.push(0x80 | (c & 63));\r\n\t\t\t} else {\r\n\t\t\t\ta.push(0xF0 | (c >> 18));\r\n\t\t\t\ta.push(0x80 | ((c >> 12) & 63));\r\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\r\n\t\t\t\ta.push(0x80 | (c & 63));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\r\n\t}\r\n\r\n\tpublic static function ofData(b:BytesData):Bytes {\r\n\t\tvar hb = untyped b.hxBytes;\r\n\t\tif (hb != null)\r\n\t\t\treturn hb;\r\n\t\treturn new Bytes(b);\r\n\t}\r\n\r\n\tpublic static function ofHex(s:String):Bytes {\r\n\t\tif ((s.length & 1) != 0)\r\n\t\t\tthrow \"Not a hex string (odd number of digits)\";\r\n\t\tvar a = new Array();\r\n\t\tvar i = 0;\r\n\t\tvar len = s.length >> 1;\r\n\t\twhile (i < len) {\r\n\t\t\tvar high = StringTools.fastCodeAt(s, i * 2);\r\n\t\t\tvar low = StringTools.fastCodeAt(s, i * 2 + 1);\r\n\t\t\thigh = (high & 0xF) + ((high & 0x40) >> 6) * 9;\r\n\t\t\tlow = (low & 0xF) + ((low & 0x40) >> 6) * 9;\r\n\t\t\ta.push(((high << 4) | low) & 0xFF);\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\r\n\t}\r\n\r\n\tpublic inline static function fastGet(b:BytesData, pos:Int):Int {\r\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\r\n\t\treturn untyped b.bytes[pos];\r\n\t}\r\n}\r\n","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage haxe.io;\r\n\r\n/**\r\n\tThis exception is raised when reading while data is no longer available in the `haxe.io.Input`.\r\n**/\r\nclass Eof {\r\n\tpublic function new() {}\r\n\r\n\t@:ifFeature(\"haxe.io.Eof.*\")\r\n\tfunction toString() {\r\n\t\treturn \"Eof\";\r\n\t}\r\n}\r\n","/*\r\n * Copyright (C)2005-2018 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage haxe.iterators;\r\n\r\n/**\r\n\tThis iterator is used only when `Array<T>` is passed to `Iterable<T>`\r\n**/\r\nclass ArrayIterator<T> {\r\n\tfinal array:Array<T>;\r\n\tvar current:Int = 0;\r\n\r\n\t/**\r\n\t\tCreate a new `ArrayIterator`.\r\n\t**/\r\n\t#if !hl inline #end\r\n\tpublic function new(array:Array<T>) {\r\n\t\tthis.array = array;\r\n\t}\r\n\r\n\t/**\r\n\t\tSee `Iterator.hasNext`\r\n\t**/\r\n\t#if !hl inline #end\r\n\tpublic function hasNext() {\r\n\t\treturn current < array.length;\r\n\t}\r\n\r\n\t/**\r\n\t\tSee `Iterator.next`\r\n\t**/\r\n\t#if !hl inline #end\r\n\tpublic function next() {\r\n\t\treturn array[current++];\r\n\t}\r\n}\r\n","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage haxe.macro;\r\n\r\nimport haxe.macro.Context;\r\nimport haxe.macro.Expr;\r\nimport haxe.macro.Type;\r\n\r\nusing Lambda;\r\n\r\n/**\r\n\tThis class provides some utility methods to work with types. It is\r\n\tbest used through 'using haxe.macro.TypeTools' syntax and then provides\r\n\tadditional methods on haxe.macro.Type instances.\r\n**/\r\n#if hl\r\n@:hlNative(\"macro\")\r\n#end\r\nclass TypeTools {\r\n\tstatic function nullable(complexType:ComplexType):ComplexType\r\n\t\treturn macro:Null<$complexType>;\r\n\r\n\tstatic function toField(cf:ClassField):Field\r\n\t\treturn {\r\n\t\t\tfunction varAccessToString(va:VarAccess, getOrSet:String):String\r\n\t\t\t\treturn {\r\n\t\t\t\t\tswitch (va) {\r\n\t\t\t\t\t\tcase AccNormal | AccCtor: \"default\";\r\n\t\t\t\t\t\tcase AccNo: \"null\";\r\n\t\t\t\t\t\tcase AccNever: \"never\";\r\n\t\t\t\t\t\tcase AccResolve: throw \"Invalid TAnonymous\";\r\n\t\t\t\t\t\tcase AccCall: getOrSet;\r\n\t\t\t\t\t\tcase AccInline: \"default\";\r\n\t\t\t\t\t\tcase AccRequire(_, _): \"default\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\tvar access = cf.isPublic ? [APublic] : [APrivate];\r\n\t\t\tif (cf.meta.has(\":final\")) {\r\n\t\t\t\taccess.push(AFinal);\r\n\t\t\t}\r\n\t\t\tif (cf.params.length == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tname: cf.name,\r\n\t\t\t\t\tdoc: cf.doc,\r\n\t\t\t\t\taccess: access,\r\n\t\t\t\t\tkind: switch ([cf.kind, cf.type]) {\r\n\t\t\t\t\t\tcase [FVar(read, write), ret]:\r\n\t\t\t\t\t\t\tFProp(varAccessToString(read, \"get\"), varAccessToString(write, \"set\"), toComplexType(ret), null);\r\n\t\t\t\t\t\tcase [FMethod(_), TFun(args, ret)]:\r\n\t\t\t\t\t\t\tFFun({\r\n\t\t\t\t\t\t\t\targs: [\r\n\t\t\t\t\t\t\t\t\tfor (a in args)\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tname: a.name,\r\n\t\t\t\t\t\t\t\t\t\t\topt: a.opt,\r\n\t\t\t\t\t\t\t\t\t\t\ttype: toComplexType(a.t),\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t],\r\n\t\t\t\t\t\t\t\tret: toComplexType(ret),\r\n\t\t\t\t\t\t\t\texpr: null,\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tthrow \"Invalid TAnonymous\";\r\n\t\t\t\t\t},\r\n\t\t\t\t\tpos: cf.pos,\r\n\t\t\t\t\tmeta: cf.meta.get(),\r\n\t\t\t\t} else {\r\n\t\t\t\tthrow \"Invalid TAnonymous\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t/**\r\n\t\tReturns a syntax-level type corresponding to Type `t`.\r\n\r\n\t\tThis function is mostly inverse to `ComplexTypeTools.toType`, but may\r\n\t\tlose some information on types that do not have a corresponding syntax\r\n\t\tversion, such as monomorphs. In these cases, the result is null.\r\n\r\n\t\tIf `t` is null, an internal exception is thrown.\r\n\t**/\r\n\tpublic static function toComplexType(type:Null<Type>):Null<ComplexType>\r\n\t\treturn {\r\n\t\t\t#if macro\r\n\t\t\tContext.toComplexType(type);\r\n\t\t\t#else\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase null:\r\n\t\t\t\t\tnull;\r\n\t\t\t\tcase TMono(_.get() => t):\r\n\t\t\t\t\tt == null ? null : toComplexType(t);\r\n\t\t\t\tcase TEnum(_.get() => baseType, params):\r\n\t\t\t\t\tTPath(toTypePath(baseType, params));\r\n\t\t\t\tcase TInst(_.get() => classType, params):\r\n\t\t\t\t\tswitch (classType.kind) {\r\n\t\t\t\t\t\tcase KTypeParameter(_):\r\n\t\t\t\t\t\t\tTPath({\r\n\t\t\t\t\t\t\t\tname: classType.name,\r\n\t\t\t\t\t\t\t\tpack: [],\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tTPath(toTypePath(classType, params));\r\n\t\t\t\t\t}\r\n\t\t\t\tcase TType(_.get() => baseType, params):\r\n\t\t\t\t\tTPath(toTypePath(baseType, params));\r\n\t\t\t\tcase TFun(args, ret):\r\n\t\t\t\t\tTFunction([for (a in args) a.opt ? nullable(toComplexType(a.t)) : toComplexType(a.t)], toComplexType(ret));\r\n\t\t\t\tcase TAnonymous(_.get() => {fields: fields}):\r\n\t\t\t\t\tTAnonymous([for (cf in fields) toField(cf)]);\r\n\t\t\t\tcase TDynamic(t):\r\n\t\t\t\t\tif (t == null) {\r\n\t\t\t\t\t\tmacro:Dynamic;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar ct = toComplexType(t);\r\n\t\t\t\t\t\tmacro:Dynamic<$ct>;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase TLazy(f):\r\n\t\t\t\t\ttoComplexType(f());\r\n\t\t\t\tcase TAbstract(_.get() => baseType, params):\r\n\t\t\t\t\tTPath(toTypePath(baseType, params));\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow \"Invalid type\";\r\n\t\t\t}\r\n\t\t\t#end\r\n\t\t}\r\n\r\n\tstatic function toTypeParam(type:Type):TypeParam\r\n\t\treturn {\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase TInst(_.get() => {kind: KExpr(e)}, _): TPExpr(e);\r\n\t\t\t\tcase _: TPType(toComplexType(type));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\tstatic function toTypePath(baseType:BaseType, params:Array<Type>):TypePath\r\n\t\treturn {\r\n\t\t\tvar module = baseType.module;\r\n\t\t\t{\r\n\t\t\t\tpack: baseType.pack,\r\n\t\t\t\tname: module.substring(module.lastIndexOf(\".\") + 1),\r\n\t\t\t\tsub: baseType.name,\r\n\t\t\t\tparams: [for (t in params) toTypeParam(t)],\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t#if (macro || display)\r\n\t/**\r\n\t\tFollows all typedefs of `t` to reach the actual type.\r\n\r\n\t\tIf `once` is true, this function does not call itself recursively,\r\n\t\totherwise it does. This can be useful in cases where intermediate\r\n\t\ttypedefs might be of interest.\r\n\r\n\t\tAffected types are monomorphs `TMono` and typedefs `TType(t,pl)`.\r\n\r\n\t\tIf `t` is null, an internal exception is thrown.\r\n\r\n\t\tUsage example:\r\n\t\t\tvar t = Context.typeof(macro null); // TMono(<mono>)\r\n\t\t\tvar ts = Context.typeof(macro \"foo\"); //TInst(String,[])\r\n\t\t\tContext.unify(t, ts);\r\n\t\t\ttrace(t); // TMono(<mono>)\r\n\t\t\ttrace(t.follow()); //TInst(String,[])\r\n\t**/\r\n\tstatic public inline function follow(t:Type, ?once:Bool):Type\r\n\t\treturn Context.follow(t, once);\r\n\r\n\t/**\r\n\t\tLike `follow`, follows all typedefs of `t` to reach the actual type.\r\n\r\n\t\tWill however follow also abstracts to their underlying implementation,\r\n\t\tif they are not a @:coreType abstract\r\n\r\n\t\tIf `t` is null, an internal exception is thrown.\r\n\r\n\t\tUsage example:\r\n\t\t\tvar t = Context.typeof(macro new Map<String, String>());\r\n\t\t\ttrace(t); // TAbstract(Map,[TInst(String,[]),TInst(String,[])])\r\n\t\t\ttrace(t.followWithAbstracts()); // TInst(haxe.ds.StringMap, [TInst(String,[])])\r\n\t**/\r\n\tstatic public inline function followWithAbstracts(t:Type, once:Bool = false):Type\r\n\t\treturn Context.followWithAbstracts(t, once);\r\n\r\n\t/**\r\n\t\tReturns true if `t1` and `t2` unify, false otherwise.\r\n\t**/\r\n\tstatic public inline function unify(t1:Type, t2:Type):Bool\r\n\t\treturn Context.unify(t1, t2);\r\n\r\n\t/**\r\n\t\tTries to extract the class instance stored inside `t`.\r\n\r\n\t\tIf `t` is a class instance `TInst(c,pl)`, c is returned.\r\n\r\n\t\tIf `t` is of a different type, an exception of type String is thrown.\r\n\r\n\t\tIf `t` is null, the result is null.\r\n\t**/\r\n\tstatic public function getClass(t:Type)\r\n\t\treturn t == null ? null : switch (follow(t)) {\r\n\t\t\tcase TInst(c, _): c.get();\r\n\t\t\tcase _: throw \"Class instance expected\";\r\n\t\t}\r\n\r\n\t/**\r\n\t\tTries to extract the enum instance stored inside `t`.\r\n\r\n\t\tIf `t` is an enum instance `TEnum(e,pl)`, e is returned.\r\n\r\n\t\tIf `t` is of a different type, an exception of type String is thrown.\r\n\r\n\t\tIf `t` is null, the result is null.\r\n\t**/\r\n\tstatic public function getEnum(t:Type)\r\n\t\treturn t == null ? null : switch (follow(t)) {\r\n\t\t\tcase TEnum(e, _): e.get();\r\n\t\t\tcase _: throw \"Enum instance expected\";\r\n\t\t}\r\n\r\n\t/**\r\n\t\tApplies the type parameters `typeParameters` to type `t` with the given\r\n\t\ttypes `concreteTypes`.\r\n\r\n\t\tThis function replaces occurrences of type parameters in `t` if they are\r\n\t\tpart of `typeParameters`. The array index of such a type parameter is\r\n\t\tthen used to lookup the concrete type in `concreteTypes`.\r\n\r\n\t\tIf `typeParameters.length` is not equal to `concreteTypes.length`, an\r\n\t\texception of type `String` is thrown.\r\n\r\n\t\tIf `typeParameters.length` is 0, `t` is returned unchanged.\r\n\r\n\t\tIf either argument is `null`, the result is unspecified.\r\n\t**/\r\n\tstatic public function applyTypeParameters(t:Type, typeParameters:Array<TypeParameter>, concreteTypes:Array<Type>):Type {\r\n\t\tif (typeParameters.length != concreteTypes.length)\r\n\t\t\tthrow 'Incompatible arguments: ${typeParameters.length} type parameters and ${concreteTypes.length} concrete types';\r\n\t\telse if (typeParameters.length == 0)\r\n\t\t\treturn t;\r\n\t\t#if (neko || eval)\r\n\t\treturn Context.load(\"apply_params\", 3)(typeParameters, concreteTypes, t);\r\n\t\t#else\r\n\t\treturn applyParams(typeParameters, concreteTypes, t);\r\n\t\t#end\r\n\t}\r\n\r\n\t#if !neko\r\n\tprivate static function applyParams(typeParameters:Array<TypeParameter>, concreteTypes:Array<Type>, t:Type):Type {\r\n\t\treturn null;\r\n\t}\r\n\t#end\r\n\r\n\t/**\r\n\t\tTransforms `t` by calling `f` on each of its subtypes.\r\n\r\n\t\tIf `t` is a compound type, `f` is called on each of its components.\r\n\r\n\t\tOtherwise `t` is returned unchanged.\r\n\r\n\t\tThe following types are considered compound:\r\n\t\t\t- TInst, TEnum, TType and TAbstract with type parameters\r\n\t\t\t- TFun\r\n\t\t\t- TAnonymous\r\n\r\n\t\tIf `t` or `f` are null, the result is unspecified.\r\n\t**/\r\n\tstatic public function map(t:Type, f:Type->Type):Type {\r\n\t\treturn switch (t) {\r\n\t\t\tcase TMono(tm):\r\n\t\t\t\tswitch (tm.get()) {\r\n\t\t\t\t\tcase null: t;\r\n\t\t\t\t\tcase var t: f(t);\r\n\t\t\t\t}\r\n\t\t\tcase TEnum(_, []) | TInst(_, []) | TType(_, []):\r\n\t\t\t\tt;\r\n\t\t\tcase TEnum(en, tl):\r\n\t\t\t\tTEnum(en, tl.map(f));\r\n\t\t\tcase TInst(cl, tl):\r\n\t\t\t\tTInst(cl, tl.map(f));\r\n\t\t\tcase TType(t2, tl):\r\n\t\t\t\tTType(t2, tl.map(f));\r\n\t\t\tcase TAbstract(a, tl):\r\n\t\t\t\tTAbstract(a, tl.map(f));\r\n\t\t\tcase TFun(args, ret):\r\n\t\t\t\tTFun(args.map(function(arg) return {\r\n\t\t\t\t\tname: arg.name,\r\n\t\t\t\t\topt: arg.opt,\r\n\t\t\t\t\tt: f(arg.t)\r\n\t\t\t\t}), f(ret));\r\n\t\t\tcase TAnonymous(an):\r\n\t\t\t\tTAnonymous(Context.load(\"map_anon_ref\", 2)(an, f));\r\n\t\t\tcase TDynamic(t2):\r\n\t\t\t\tt == t2 ? t : TDynamic(f(t2));\r\n\t\t\tcase TLazy(ft):\r\n\t\t\t\tvar ft = ft();\r\n\t\t\t\tvar ft2 = f(ft);\r\n\t\t\t\tft == ft2 ? t : ft2;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\tCalls function `f` on each component of type `t`.\r\n\r\n\t\tIf `t` is not a compound type, this operation has no effect.\r\n\r\n\t\tThe following types are considered compound:\r\n\t\t\t- TInst, TEnum, TType and TAbstract with type parameters\r\n\t\t\t- TFun\r\n\t\t\t- TAnonymous\r\n\r\n\t\tIf `t` or `f` are null, the result is unspecified.\r\n\t**/\r\n\tstatic public function iter(t:Type, f:Type->Void):Void {\r\n\t\tswitch (t) {\r\n\t\t\tcase TMono(tm):\r\n\t\t\t\tvar t = tm.get();\r\n\t\t\t\tif (t != null)\r\n\t\t\t\t\tf(t);\r\n\t\t\tcase TEnum(_, tl) | TInst(_, tl) | TType(_, tl) | TAbstract(_, tl):\r\n\t\t\t\tfor (t in tl)\r\n\t\t\t\t\tf(t);\r\n\t\t\tcase TDynamic(t2):\r\n\t\t\t\tif (t != t2)\r\n\t\t\t\t\tf(t2);\r\n\t\t\tcase TLazy(ft):\r\n\t\t\t\tf(ft());\r\n\t\t\tcase TAnonymous(an):\r\n\t\t\t\tfor (field in an.get().fields)\r\n\t\t\t\t\tf(field.type);\r\n\t\t\tcase TFun(args, ret):\r\n\t\t\t\tfor (arg in args)\r\n\t\t\t\t\tf(arg.t);\r\n\t\t\t\tf(ret);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\tConverts type `t` to a human-readable String representation.\r\n\t**/\r\n\tstatic public function toString(t:Type):String {\r\n\t\t#if (neko || eval)\r\n\t\treturn Context.load(\"s_type\", 1)(t);\r\n\t\t#else\r\n\t\treturn null;\r\n\t\t#end\r\n\t}\r\n\t#end\r\n\r\n\t/**\r\n\t\tResolves the field named `name` on class `c`.\r\n\r\n\t\tIf `isStatic` is true, the classes' static fields are checked. Otherwise\r\n\t\tthe classes' member fields are checked.\r\n\r\n\t\tIf the field is found, it is returned. Otherwise if `c` has a super\r\n\t\tclass, `findField` recursively checks that super class. Otherwise null\r\n\t\tis returned.\r\n\r\n\t\tIf any argument is null, the result is unspecified.\r\n\t**/\r\n\tstatic public function findField(c:ClassType, name:String, isStatic:Bool = false):Null<ClassField> {\r\n\t\tvar field = (isStatic ? c.statics : c.fields).get().find(function(field) return field.name == name);\r\n\t\treturn if (field != null) field; else if (c.superClass != null) findField(c.superClass.t.get(), name, isStatic); else null;\r\n\t}\r\n}\r\n","/*\r\n * Copyright (C)2005-2019 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js;\r\n\r\nimport js.Syntax; // import it here so it's always available in the compiler\r\n\r\n@:dox(hide)\r\nclass Boot {\r\n\tstatic inline function isClass(o:Dynamic):Bool {\r\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\r\n\t}\r\n\r\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\r\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\r\n\t}\r\n\r\n\tstatic inline function isEnum(e:Dynamic):Bool {\r\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\r\n\t}\r\n\r\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\r\n\t\tif (o == null) {\r\n\t\t\treturn null;\r\n\t\t} else if (Std.isOfType(o, Array)) {\r\n\t\t\treturn Array;\r\n\t\t} else {\r\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\r\n\t\t\tif (cl != null)\r\n\t\t\t\treturn cl;\r\n\t\t\tvar name = __nativeClassName(o);\r\n\t\t\tif (name != null)\r\n\t\t\t\treturn __resolveNativeClass(name);\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t@:ifFeature(\"has_enum\")\r\n\tprivate static function __string_rec(o, s:String) {\r\n\t\tuntyped {\r\n\t\t\tif (o == null)\r\n\t\t\t\treturn \"null\";\r\n\t\t\tif (s.length >= 5)\r\n\t\t\t\treturn \"<...>\"; // too much deep recursion\r\n\t\t\tvar t = js.Syntax.typeof(o);\r\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\r\n\t\t\t\tt = \"object\";\r\n\t\t\tswitch (t) {\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\t#if !js_enums_as_arrays\r\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\r\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\r\n\t\t\t\t\t\tvar con = e.__constructs__[o._hx_index];\r\n\t\t\t\t\t\tvar n = con._hx_name;\r\n\t\t\t\t\t\tif (con.__params__) {\r\n\t\t\t\t\t\t\ts += \"\\t\";\r\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn n;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\t#end\r\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\r\n\t\t\t\t\t\t#if js_enums_as_arrays\r\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\r\n\t\t\t\t\t\t\tif (o.length == 2)\r\n\t\t\t\t\t\t\t\treturn o[0];\r\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\r\n\t\t\t\t\t\t\ts += \"\\t\";\r\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\r\n\t\t\t\t\t\t\t\tif (i != 2)\r\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn str + \")\";\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\t#end\r\n\t\t\t\t\t\tvar str = \"[\";\r\n\t\t\t\t\t\ts += \"\\t\";\r\n\t\t\t\t\t\tfor (i in 0...o.length)\r\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\r\n\t\t\t\t\t\tstr += \"]\";\r\n\t\t\t\t\t\treturn str;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar tostr;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\ttostr = untyped o.toString;\r\n\t\t\t\t\t} catch (e:Dynamic) {\r\n\t\t\t\t\t\t// strange error on IE\r\n\t\t\t\t\t\treturn \"???\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (tostr != null && tostr != js.Syntax.code(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\r\n\t\t\t\t\t\tvar s2 = o.toString();\r\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\r\n\t\t\t\t\t\t\treturn s2;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar str = \"{\\n\";\r\n\t\t\t\t\ts += \"\\t\";\r\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\r\n\t\t\t\t\tvar k:String = null;\r\n\t\t\t\t\tjs.Syntax.code(\"for( {0} in {1} ) {\", k, o);\r\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\r\n\t\t\t\t\t\tjs.Syntax.code(\"continue\");\r\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\r\n\t\t\t\t\t\tjs.Syntax.code(\"continue\");\r\n\t\t\t\t\tif (str.length != 2)\r\n\t\t\t\t\t\tstr += \", \\n\";\r\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\r\n\t\t\t\t\tjs.Syntax.code(\"}\");\r\n\t\t\t\t\ts = s.substring(1);\r\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\r\n\t\t\t\t\treturn str;\r\n\t\t\t\tcase \"function\":\r\n\t\t\t\t\treturn \"<function>\";\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\treturn o;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn String(o);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\r\n\t\tif (cc == null)\r\n\t\t\treturn false;\r\n\t\tif (cc == cl)\r\n\t\t\treturn true;\r\n\t\tvar intf:Dynamic = cc.__interfaces__;\r\n\t\tif (intf != null\r\n\t\t\t// ES6 classes inherit statics, so we want to avoid accessing inherited `__interfaces__`\r\n\t\t\t#if (js_es >= 6) && (cc.__super__ == null || cc.__super__.__interfaces__ != intf) #end\r\n\t\t) {\r\n\t\t\tfor (i in 0...intf.length) {\r\n\t\t\t\tvar i:Dynamic = intf[i];\r\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn __interfLoop(cc.__super__, cl);\r\n\t}\r\n\r\n\t@:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\r\n\t\tif (cl == null)\r\n\t\t\treturn false;\r\n\t\tswitch (cl) {\r\n\t\t\tcase Int:\r\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\r\n\t\t\tcase Float:\r\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\r\n\t\t\tcase Bool:\r\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\r\n\t\t\tcase String:\r\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\r\n\t\t\tcase Array:\r\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\r\n\t\t\tcase Dynamic:\r\n\t\t\t\treturn o != null;\r\n\t\t\tdefault:\r\n\t\t\t\tif (o != null) {\r\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\r\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\r\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\r\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// do not use isClass/isEnum here\r\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\r\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\r\n\t\t\t\t#if js_enums_as_arrays\r\n\t\t\t\treturn o.__enum__ == cl;\r\n\t\t\t\t#else\r\n\t\t\t\treturn untyped __feature__(\r\n\t\t\t\t\t\"has_enum\",\r\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\r\n\t\t\t\t\tfalse\r\n\t\t\t\t);\r\n\t\t\t\t#end\r\n\t\t}\r\n\t}\r\n\r\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\r\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\r\n\t}\r\n\r\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\r\n\t\treturn __interfLoop(getClass(o), iface);\r\n\t}\r\n\r\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\r\n\t\tif (o == null || __instanceof(o, t))\r\n\t\t\treturn o;\r\n\t\telse\r\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\r\n\t}\r\n\r\n\tstatic var __toStr:js.lib.Function;\r\n\r\n\tstatic function __init__() {\r\n\t\tBoot.__toStr = (cast {}).toString;\r\n\t}\r\n\r\n\t// get native JS [[Class]]\r\n\tstatic function __nativeClassName(o:Dynamic):String {\r\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\r\n\t\t// exclude general Object and Function\r\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\r\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\r\n\t\t\treturn null;\r\n\t\treturn name;\r\n\t}\r\n\r\n\t// check for usable native JS object\r\n\tstatic function __isNativeObj(o:Dynamic):Bool {\r\n\t\treturn __nativeClassName(o) != null;\r\n\t}\r\n\r\n\t// resolve native JS class in the global scope:\r\n\tstatic function __resolveNativeClass(name:String) {\r\n\t\treturn js.Lib.global[cast name];\r\n\t}\r\n}\r\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node;\r\n\r\n/**\r\n\tKey/value access helper.\r\n**/\r\nabstract KeyValue<K, V>(Array<Any>) {\r\n\tpublic var key(get, never):K;\r\n\tpublic var value(get, never):V;\r\n\r\n\tinline function get_key():K {\r\n\t\treturn this[0];\r\n\t}\r\n\r\n\tinline function get_value():V {\r\n\t\treturn this[1];\r\n\t}\r\n}\r\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node.stream;\r\n\r\nimport haxe.extern.EitherType;\r\nimport js.node.Stream;\r\nimport js.node.events.EventEmitter.Event;\r\nimport js.node.stream.Readable.IReadable;\r\n#if haxe4\r\nimport js.lib.Error;\r\nimport js.lib.Object;\r\nimport js.lib.Uint8Array;\r\n#else\r\nimport js.Error;\r\nimport js.html.Uint8Array;\r\n#end\r\n\r\n/**\r\n\tWritable streams are an abstraction for a destination to which data is written.\r\n\r\n\t@see https://nodejs.org/api/stream.html#stream_writable_streams\r\n**/\r\n@:enum abstract WritableEvent<T:haxe.Constraints.Function>(Event<T>) to Event<T> {\r\n\t/**\r\n\t\tThe `'close'` event is emitted when the stream and any of its underlying resources\r\n\t\t(a file descriptor, for example) have been closed.\r\n\t\tThe event indicates that no more events will be emitted, and no further computation will occur.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_close\r\n\t**/\r\n\tvar Close:WritableEvent<Void->Void> = \"close\";\r\n\r\n\t/**\r\n\t\tIf a call to stream.write(chunk) returns `false`, the `'drain'` event will be emitted\r\n\t\twhen it is appropriate to resume writing data to the stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_drain\r\n\t**/\r\n\tvar Drain:WritableEvent<Void->Void> = \"drain\";\r\n\r\n\t/**\r\n\t\tThe `'error'` event is emitted if an `error` occurred while writing or piping data.\r\n\t\tThe listener callback is passed a single Error argument when called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_error\r\n\t**/\r\n\tvar Error:WritableEvent<Error->Void> = \"error\";\r\n\r\n\t/**\r\n\t\tThe `'finish'` event is emitted after the stream.end() method has been called,\r\n\t\tand all data has been flushed to the underlying system.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_finish\r\n\t**/\r\n\tvar Finish:WritableEvent<Void->Void> = \"finish\";\r\n\r\n\t/**\r\n\t\tThe `'pipe'` event is emitted when the stream.pipe() method is called on a readable stream,\r\n\t\tadding this writable to its set of destinations.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_pipe\r\n\t**/\r\n\tvar Pipe:WritableEvent<IReadable->Void> = \"pipe\";\r\n\r\n\t/**\r\n\t\tThe `'unpipe'` event is emitted when the stream.unpipe() method is called on a Readable stream,\r\n\t\tremoving this Writable from its set of destinations.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_unpipe\r\n\t**/\r\n\tvar Unpipe:WritableEvent<IReadable->Void> = \"unpipe\";\r\n}\r\n\r\n/**\r\n\tThe Writable stream interface is an abstraction for a destination that you are writing data to.\r\n\r\n\tExamples of writable streams include:\r\n\r\n\t\t- http requests, on the client\r\n\t\t- http responses, on the server\r\n\t\t- fs write streams\r\n\t\t- zlib streams\r\n\t\t- crypto streams\r\n\t\t- tcp sockets\r\n\t\t- child process stdin\r\n\t\t- process.stdout, process.stderr\r\n**/\r\n@:jsRequire(\"stream\", \"Writable\")\r\nextern class Writable<TSelf:Writable<TSelf>> extends Stream<TSelf> implements IWritable {\r\n\t/**\r\n\t\tThe `writable.cork()` method forces all written data to be buffered in memory.\r\n\t\tThe buffered data will be flushed when either the `stream.uncork()` or `stream.end()` methods are called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_cork\r\n\t**/\r\n\tfunction cork():Void;\r\n\r\n\t/**\r\n\t\tDestroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event unless `emitClose` is set in `false`.\r\n\t\tAfter this call, the writable stream has ended and subsequent calls to `write()` or `end()` will result in an `ERR_STREAM_DESTROYED` error.\r\n\t\tThis is a destructive and immediate way to destroy a stream. Previous calls to `write()` may not have drained, and may trigger an `ERR_STREAM_DESTROYED` error.\r\n\t\tUse `end()` instead of destroy if data should flush before close, or wait for the `'drain'` event before destroying the stream.\r\n\t\tImplementors should not override this method, but instead implement `writable._destroy()`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_destroy_error\r\n\t**/\r\n\tfunction destroy(?error:Error):TSelf;\r\n\r\n\t/**\r\n\t\tIs `true` after `writable.destroy()` has been called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_destroyed\r\n\t**/\r\n\tvar destroyed(default, null):Bool;\r\n\r\n\t/**\r\n\t\tCalling the `writable.end()` method signals that no more data will be written to the Writable.\r\n\t\tThe optional `chunk` and `encoding` arguments allow one final additional chunk of data to be written immediately before closing the stream.\r\n\t\tIf provided, the optional `callback` function is attached as a listener for the 'finish' event.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback\r\n\t**/\r\n\t@:overload(function(?callback:EitherType<Void->Void, Null<Error>->Void>):Void {})\r\n\tfunction end(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Void;\r\n\r\n\t/**\r\n\t\tThe `writable.setDefaultEncoding()` method sets the default `encoding` for a Writable stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_setdefaultencoding_encoding\r\n\t**/\r\n\tfunction setDefaultEncoding(encoding:String):TSelf;\r\n\r\n\t/**\r\n\t\tThe `writable.uncork()` method flushes all data buffered since `stream.cork()` was called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_uncork\r\n\t**/\r\n\tfunction uncork():Void;\r\n\r\n\t/**\r\n\t\tIs `true` if it is safe to call `writable.write()`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writable\r\n\t**/\r\n\tvar writable(default, null):Bool;\r\n\r\n\t/**\r\n\t\tIs `true` after `writable.end()` has been called. This property\r\n\t\tdoes not indicate whether the data has been flushed, for this use\r\n\t\t`writable.writableFinished` instead.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writableended\r\n\t**/\r\n\tvar writableEnded(default, null):Bool;\r\n\r\n\t/**\r\n\t\tIs set to `true` immediately before the 'finish' event is emitted.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writablefinished\r\n\t**/\r\n\tvar writableFinished(default, null):Bool;\r\n\r\n\t/**\r\n\t\tReturn the value of `highWaterMark` passed when constructing this `Writable`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writablehighwatermark\r\n\t**/\r\n\tvar writablehighWaterMark(default, null):Int;\r\n\r\n\t/**\r\n\t\tThis property contains the number of bytes (or objects) in the queue ready to be written.\r\n\t\tThe value provides introspection data regarding the status of the `highWaterMark`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writablelength\r\n\t**/\r\n\tvar writableLength(default, null):Int;\r\n\r\n\t/**\r\n\t\tGetter for the property `objectMode` of a given `Writable` stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writableobjectmode\r\n\t**/\r\n\tvar writableObjectMode(default, null):Bool;\r\n\r\n\t/**\r\n\t\tThe `writable.write()` method writes some data to the stream, and calls the supplied `callback` once the data has been fully handled.\r\n\t\tIf an error occurs, the `callback` may or may not be called with the error as its first argument.\r\n\t\tTo reliably detect write errors, add a listener for the `'error'` event.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\r\n\t**/\r\n\tfunction write(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Bool;\r\n\r\n\t// --------- API for implementing a Writable Stream -----------------------\r\n\r\n\t/**\r\n\t\t@see https://nodejs.org/api/stream.html#stream_constructor_new_stream_writable_options\r\n\t**/\r\n\tfunction new(?options:WritableNewOptionsAdapter);\r\n\r\n\t/**\r\n\t\tAll `Writable` stream implementations must provide a `writable._write()` method to send data to the underlying resource.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback_1\r\n\t**/\r\n\tprivate function _write(chunk:Dynamic, encoding:String, callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThis function **MUST NOT** be called by application code directly.\r\n\t\tIt should be implemented by child classes, and called by the internal `Writable` class methods only.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writev_chunks_callback\r\n\t**/\r\n\tprivate function _writev(chunks:Array<Chunk>, callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThe `_destroy()` method is called by `writable.destroy()`.\r\n\t\tIt can be overridden by child classes but it **must not** be called directly.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_destroy_err_callback\r\n\t**/\r\n\tprivate function _destroy(err:Null<Error>, callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThe `_final()` method **must not** be called directly.\r\n\t\tt may be implemented by child classes, and if so, will be called by the internal `Writable` class methods only.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_final_callback\r\n\t**/\r\n\tprivate function _final(callback:Null<Error>->Void):Void;\r\n\r\n\t// --------- TTY module API  ----------------------------------------------\r\n\r\n\t/**\r\n\t\tTerminal write streams (i.e. process.stdout) have this property set to true.\r\n\t\tIt is false for any other write streams.\r\n\r\n\t\t@see https://nodejs.org/api/tty.html#tty_writestream_istty\r\n\t**/\r\n\tvar isTTY(default, null):Bool;\r\n}\r\n\r\n/**\r\n\t@see https://nodejs.org/api/stream.html#stream_constructor_new_stream_writable_options\r\n**/\r\ntypedef WritableNewOptions = {\r\n\t/**\r\n\t\t`highWaterMark` <number> Buffer level when stream.write() starts returning `false`. Default: `16384` (16kb), or 16 for `objectMode` streams.\r\n\t**/\r\n\t@:optional var highWaterMark:Int;\r\n\r\n\t/**\r\n\t\t`decodeStrings` <boolean> Whether to encode `string`s passed to stream.write() to `Buffer`s (with the encoding specified in the stream.write() call) before passing them to stream._write().\r\n\t\tOther types of data are not converted (i.e. `Buffer`s are not decoded into `string`s). Setting to false will prevent strings from being converted.\r\n\t\tDefault: `true`.\r\n\t**/\r\n\t@:optional var decodeStrings:Bool;\r\n\r\n\t/**\r\n\t\t`defaultEncoding` <string> The default encoding that is used when no encoding is specified as an argument to stream.write().\r\n\t\tDefault: `'utf8'`.\r\n\t**/\r\n\t@:optional var defaultEncoding:String;\r\n\r\n\t/**\r\n\t\t`objectMode` <boolean> Whether or not the stream.write(anyObj) is a valid operation. When set,\r\n\t\tit becomes possible to write JavaScript values other than string, `Buffer` or `Uint8Array` if supported by the stream implementation.\r\n\t\tDefault: `false`.\r\n\t**/\r\n\t@:optional var objectMode:Bool;\r\n\r\n\t/**\r\n\t\t`emitClose` <boolean> Whether or not the stream should emit `'close'` after it has been destroyed.\r\n\t\tDefault: `true`.\r\n\t**/\r\n\t@:optional var emitClose:Bool;\r\n\r\n\t/**\r\n\t\t`write` <Function> Implementation for the stream._write() method.\r\n\t**/\r\n\t#if haxe4\r\n\t@:optional var write:(chunk:Dynamic, encoding:String, callback:Null<Error>->Void) -> Void;\r\n\t#else\r\n\t@:optional var write:Dynamic->String->Null<Error>->Void->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\t`writev` <Function> Implementation for the stream._writev() method.\r\n\t**/\r\n\t#if haxe4\r\n\t@:optional var writev:(chunks:Array<Chunk>, callback:Null<Error>->Void) -> Void;\r\n\t#else\r\n\t@:optional var writev:Array<Chunk>->(Null<Error>->Void)->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\t`destroy` <Function> Implementation for the stream._destroy() method.\r\n\t**/\r\n\t#if haxe4\r\n\t@:optional var destroy:(error:Null<Error>, callback:Null<Error>->Void) -> Void;\r\n\t#else\r\n\t@:optional var destroy:Null<Error>->(Null<Error>->Void)->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\t`final` <Function> Implementation for the stream._final() method.\r\n\t**/\r\n\t// TODO @native in typedef cannot work now\r\n\t// @:native(\"final\")\r\n\t#if haxe4\r\n\t@:optional var final_:(error:Null<Error>) -> Void;\r\n\t#else\r\n\t@:optional var final_:Null<Error>->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\t`autoDestroy` <boolean> Whether this stream should automatically call .destroy() on itself after ending. Default: false.\r\n\t**/\r\n\t@:optional var autoDestroy:Bool;\r\n}\r\n\r\n@:forward\r\nabstract WritableNewOptionsAdapter(WritableNewOptions) {\r\n\t@:from\r\n\tpublic static function from(options:WritableNewOptions):WritableNewOptionsAdapter {\r\n\t\tif (!Reflect.hasField(options, \"final\")) {\r\n\t\t\t#if haxe4\r\n\t\t\tObject.defineProperty(options, \"final\", {get: function() return options.final_});\r\n\t\t\t#else\r\n\t\t\tuntyped __js__(\"Object.defineProperty({0}, {1}, {2})\", options, \"final\", {get: function() return options.final_});\r\n\t\t\t#end\r\n\t\t}\r\n\t\treturn cast options;\r\n\t}\r\n}\r\n\r\n/**\r\n\tWritable interface used for type parameter constraints.\r\n\tSee `Writable` for actual class documentation.\r\n**/\r\n@:remove\r\nextern interface IWritable extends IStream {\r\n\tfunction cork():Void;\r\n\r\n\tfunction destroy(?error:Error):IWritable;\r\n\r\n\tvar destroyed(default, null):Bool;\r\n\r\n\t@:overload(function(?callback:EitherType<Void->Void, Null<Error>->Void>):Void {})\r\n\tfunction end(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Void;\r\n\r\n\tfunction setDefaultEncoding(encoding:String):IWritable;\r\n\r\n\tfunction uncork():Void;\r\n\r\n\tvar writable(default, null):Bool;\r\n\r\n\tvar writableEnded(default, null):Bool;\r\n\r\n\tvar writableFinished(default, null):Bool;\r\n\r\n\tvar writablehighWaterMark(default, null):Int;\r\n\r\n\tvar writableLength(default, null):Int;\r\n\r\n\tvar writableObjectMode(default, null):Bool;\r\n\r\n\tfunction write(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Bool;\r\n\r\n\tvar isTTY(default, null):Bool;\r\n}\r\n\r\ntypedef Chunk = {\r\n\tvar chunk:Dynamic;\r\n\tvar encoding:String;\r\n}\r\n","package safety;\n\n#if (haxe >= version('4.1.0'))\nclass SafetyException extends haxe.Exception {}\n#else\nclass SafetyException {\n\tpublic var message:String;\n\n\tpublic function new(msg:String) {\n\t\tmessage = msg;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n}\n#end","package safety;\n\nclass NullPointerException extends SafetyException {}","package sys;\r\n\r\nimport js.node.Fs;\r\nimport js.node.Path;\r\n#if haxe4\r\nimport js.lib.Error;\r\n#else\r\nimport js.Error;\r\n#end\r\n\r\n@:dce\r\n@:coreApi\r\nclass FileSystem {\r\n\tpublic static function exists(path:String):Bool {\r\n\t\treturn try {\r\n\t\t\tFs.accessSync(path);\r\n\t\t\ttrue;\r\n\t\t} catch (_:Dynamic) false;\r\n\t}\r\n\r\n\tpublic static inline function rename(path:String, newPath:String):Void {\r\n\t\tFs.renameSync(path, newPath);\r\n\t}\r\n\r\n\tpublic static inline function stat(path:String):sys.FileStat {\r\n\t\treturn cast Fs.statSync(path);\r\n\t}\r\n\r\n\tpublic static inline function fullPath(relPath:String):String {\r\n\t\treturn try Fs.realpathSync(relPath) catch (e:Dynamic) null;\r\n\t}\r\n\r\n\tpublic static inline function absolutePath(relPath:String):String {\r\n\t\treturn js.node.Path.resolve(relPath);\r\n\t}\r\n\r\n\tpublic static function isDirectory(path:String):Bool {\r\n\t\treturn try Fs.statSync(path).isDirectory() catch (e:Dynamic) false;\r\n\t}\r\n\r\n\tpublic static function createDirectory(path:String):Void {\r\n\t\ttry {\r\n\t\t\tFs.mkdirSync(path);\r\n\t\t} catch (e:Dynamic) {\r\n\t\t\tif (e.code == \"ENOENT\") {\r\n\t\t\t\t// parent doesn't exist - create parent and then this dir\r\n\t\t\t\tcreateDirectory(Path.dirname(path));\r\n\t\t\t\tFs.mkdirSync(path);\r\n\t\t\t} else {\r\n\t\t\t\t// some other error - check if path is a dir, rethrow the error if not\r\n\t\t\t\t// (the `(e : Error)` cast is here to avoid HaxeError wrapping, though we need to investigate this in Haxe itself)\r\n\t\t\t\tvar stat = try Fs.statSync(path) catch (_:Dynamic) throw(e : Error);\r\n\t\t\t\tif (!stat.isDirectory())\r\n\t\t\t\t\tthrow(e : Error);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static inline function deleteFile(path:String):Void {\r\n\t\tFs.unlinkSync(path);\r\n\t}\r\n\r\n\tpublic static inline function deleteDirectory(path:String):Void {\r\n\t\tif (exists(path)) {\r\n\t\t\tfor (file in readDirectory(path)) {\r\n\t\t\t\tvar curPath = path + \"/\" + file;\r\n\t\t\t\tif (isDirectory(curPath)) {\r\n\t\t\t\t\tdeleteDirectory(curPath);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdeleteFile(curPath);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tjs.node.Fs.rmdirSync(path);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static inline function readDirectory(path:String):Array<String> {\r\n\t\treturn Fs.readdirSync(path);\r\n\t}\r\n}\r\n","package sys.io;\r\n\r\nimport haxe.io.Bytes;\r\nimport haxe.io.Eof;\r\nimport haxe.io.Error;\r\nimport js.node.Buffer;\r\nimport js.node.Fs;\r\n\r\n@:coreApi\r\nclass FileInput extends haxe.io.Input {\r\n\tvar fd:Int;\r\n\tvar pos:Int;\r\n\r\n\t@:allow(sys.io.File)\r\n\tfunction new(fd:Int) {\r\n\t\tthis.fd = fd;\r\n\t\tpos = 0;\r\n\t}\r\n\r\n\toverride public function readByte():Int {\r\n\t\tvar buf = Buffer.alloc(1);\r\n\t\tvar bytesRead = try {\r\n\t\t\tFs.readSync(fd, buf, 0, 1, pos);\r\n\t\t} catch (e:Dynamic) {\r\n\t\t\tif (e.code == \"EOF\")\r\n\t\t\t\tthrow new Eof();\r\n\t\t\telse\r\n\t\t\t\tthrow Error.Custom(e);\r\n\t\t}\r\n\t\tif (bytesRead == 0)\r\n\t\t\tthrow new Eof();\r\n\t\tpos++;\r\n\t\treturn buf[0];\r\n\t}\r\n\r\n\toverride public function readBytes(s:Bytes, pos:Int, len:Int):Int {\r\n\t\tvar buf = Buffer.hxFromBytes(s);\r\n\t\tvar bytesRead = try {\r\n\t\t\tFs.readSync(fd, buf, pos, len, this.pos);\r\n\t\t} catch (e:Dynamic) {\r\n\t\t\tif (e.code == \"EOF\")\r\n\t\t\t\tthrow new Eof();\r\n\t\t\telse\r\n\t\t\t\tthrow Error.Custom(e);\r\n\t\t}\r\n\t\tif (bytesRead == 0)\r\n\t\t\tthrow new Eof();\r\n\t\tthis.pos += bytesRead;\r\n\t\treturn bytesRead;\r\n\t}\r\n\r\n\toverride public function close():Void {\r\n\t\tFs.closeSync(fd);\r\n\t}\r\n\r\n\tpublic function seek(p:Int, pos:FileSeek):Void {\r\n\t\tswitch (pos) {\r\n\t\t\tcase SeekBegin:\r\n\t\t\t\tthis.pos = p;\r\n\t\t\tcase SeekEnd:\r\n\t\t\t\tthis.pos = cast Fs.fstatSync(fd).size + p;\r\n\t\t\tcase SeekCur:\r\n\t\t\t\tthis.pos += p;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function tell():Int {\r\n\t\treturn pos;\r\n\t}\r\n\r\n\tpublic function eof():Bool {\r\n\t\treturn pos >= Fs.fstatSync(fd).size;\r\n\t}\r\n}\r\n","package sys.io;\r\n\r\nimport haxe.io.Bytes;\r\nimport haxe.io.Eof;\r\nimport haxe.io.Error;\r\nimport js.node.Buffer;\r\nimport js.node.Fs;\r\n\r\n@:coreApi\r\nclass FileOutput extends haxe.io.Output {\r\n\tvar fd:Int;\r\n\tvar pos:Int;\r\n\r\n\t@:allow(sys.io.File)\r\n\tfunction new(fd:Int) {\r\n\t\tthis.fd = fd;\r\n\t\tpos = 0;\r\n\t}\r\n\r\n\toverride public function writeByte(b:Int):Void {\r\n\t\tvar buf = Buffer.alloc(1);\r\n\t\tbuf[0] = b;\r\n\t\tFs.writeSync(fd, buf, 0, 1, pos);\r\n\t\tpos++;\r\n\t}\r\n\r\n\toverride public function writeBytes(s:Bytes, pos:Int, len:Int):Int {\r\n\t\tvar buf = Buffer.hxFromBytes(s);\r\n\t\tvar wrote = Fs.writeSync(fd, buf, pos, len, this.pos);\r\n\t\tthis.pos += wrote;\r\n\t\treturn wrote;\r\n\t}\r\n\r\n\toverride public function close():Void {\r\n\t\tFs.closeSync(fd);\r\n\t}\r\n\r\n\tpublic function seek(p:Int, pos:FileSeek):Void {\r\n\t\tswitch (pos) {\r\n\t\t\tcase SeekBegin:\r\n\t\t\t\tthis.pos = p;\r\n\t\t\tcase SeekEnd:\r\n\t\t\t\tthis.pos = cast Fs.fstatSync(fd).size + p;\r\n\t\t\tcase SeekCur:\r\n\t\t\t\tthis.pos += p;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function tell():Int {\r\n\t\treturn pos;\r\n\t}\r\n}\r\n","package systems;\r\n\r\nimport haxe.exceptions.NotImplementedException;\r\nimport discord_js.Message;\r\nimport components.Command;\r\nimport ecs.System;\r\nclass CommandBase extends System {\r\n\t@:fastFamily var commands:{command:Command, message:Message};\r\n\toverride function update(_dt:Float) {\r\n\t\tif (!Main.connected) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\titerate(commands, entity -> {\r\n\t\t\tif (command.name == this.name) {\r\n\t\t\t\tthis.run(command, message);\r\n\t\t\t\tthis.commands.remove(entity);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tfunction run(command:Command, message:Message):Void {\r\n\t\tthrow NotImplementedException;\r\n\t}\r\n\tvar block:Bool;\r\n\tvar name(get, never):String;\r\n\tfunction get_name():String {\r\n\t\tthrow NotImplementedException;\r\n\t}\r\n}","package systems;\r\n\r\nimport ecs.System;\r\n\r\nclass Messages extends System {\r\n\t\r\n}","package systems.commands;\r\n\r\nimport discord_js.TextChannel;\r\nimport discord_js.MessageEmbed;\r\nimport sys.FileSystem;\r\nimport ecs.System;\r\nimport discord_js.Message;\r\nimport components.Command;\r\nimport js.node.ChildProcess.spawn;\r\n\r\nclass Haxelib extends System {\r\n\t@:fastFamily var commands:{command:Command, message:Message};\r\n\tvar message_id:String;\r\n\tfinal super_mod_id:String = '198916468312637440';\r\n\t\r\n\toverride function update(_dt:Float) {\r\n\t\tif (!Main.connected) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\titerate(commands, entity -> {\r\n\t\t\tif (command.name == this.get_name()) {\r\n\t\t\t\tthis.run(command, message);\r\n\t\t\t\tthis.commands.remove(entity);\r\n\t\t\t}\r\n\t\t});\r\n\t}\t\r\n\r\n\tfunction run(command:Command, message:Message) {\r\n\t\tif (command.content != \"list\" || !hasRole(this.super_mod_id, message)) {\r\n\t\t\tmessage.react('').then(null, null);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar channel = (message.channel:TextChannel);\r\n\t\tvar commands = [];\r\n\t\tfor (c in command.content.split(' ')) {\r\n\t\t\tcommands.push(c);\r\n\t\t}\r\n\r\n\t\tvar process = './haxe/haxelib';\r\n\t\tif (!FileSystem.exists(process)) {\r\n\t\t\tprocess = 'haxelib';\r\n\t\t}\r\n\r\n\t\tvar ls = spawn(process, commands);\r\n\t\tls.stdout.on('data', function(data:String) {\r\n\t\t\tif (!data.contains(\"KB\") && !data.contains(\"%\")) {\r\n\t\t\t\tif (this.message_id == null) {\r\n\t\t\t\t\tvar embed = new MessageEmbed();\r\n\t\t\t\t\tembed.setTitle('Status');\r\n\t\t\t\t\tembed.setDescription(data);\r\n\t\t\t\t\tchannel.send(embed).then((data) -> {\r\n\t\t\t\t\t\tthis.message_id = data.id;\r\n\t\t\t\t\t}, null);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchannel.messages.fetch(this.message_id).then((response) -> {\r\n\t\t\t\t\t\tvar embed = response.embeds[0];\r\n\t\t\t\t\t\tembed.description += '\\n$data';\r\n\t\t\t\t\t\tresponse.edit(embed);\r\n\t\t\t\t\t}, null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tls.stderr.on('data', (data) -> {\r\n\t\t\tvar embed = new MessageEmbed();\r\n\t\t\tembed.type = 'article';\r\n\t\t\tembed.addField('Haxelib Error', data);\r\n\r\n\t\t\tchannel.send(embed);\r\n\t\t});\r\n\r\n\t\tls.on('close', (data) -> {\r\n\t\t\tthis.message_id = null;\r\n\t\t});\r\n\t}\r\n\r\n\tfunction get_name():String {\r\n\t\treturn '+haxelib';\r\n\t}\r\n}","package systems.commands;\r\n\r\nimport discord_js.Message;\r\nimport components.Command;\r\n\r\nclass Hi extends CommandBase {\r\n\toverride function run(command:Command, message:Message) {\r\n\t\tmessage.reply('Hey there');\r\n\t}\r\n\r\n\toverride function get_name():String {\r\n\t\treturn '!hi';\r\n\t}\r\n}\r\n"],
"names":[],
"mappings":"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"
}